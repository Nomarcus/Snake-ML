<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Snake Simulation - Intelligent Snake Experience</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    :root {
      --primary: #667eea;
      --secondary: #764ba2;
      --accent: #f093fb;
      --success: #4ade80;
      --danger: #ef4444;
      --warning: #fbbf24;
      --dark: #1a1a2e;
      --darker: #0f0f23;
      --light: #eef2ff;
      --text: #e2e8f0;
      --glass: rgba(255, 255, 255, 0.1);
      --glass-border: rgba(255, 255, 255, 0.2);
    }
    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, var(--darker) 0%, var(--dark) 100%);
      min-height: 100vh;
      color: var(--text);
      overflow-x: hidden;
      position: relative;
    }
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, var(--primary) 0%, transparent 70%);
      opacity: 0.03;
      animation: rotate 60s linear infinite;
      z-index: -1;
    }
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    nav {
      background: var(--glass);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid var(--glass-border);
      padding: 1rem 2rem;
      position: sticky;
      top: 0;
      z-index: 1000;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    }
    .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .logo {
      font-size: 1.8rem;
      font-weight: 800;
      background: linear-gradient(135deg, var(--accent) 0%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .logo::before {
      content: 'üêç';
      font-size: 2rem;
      -webkit-text-fill-color: initial;
    }
    .nav-links {
      display: flex;
      gap: 2rem;
      list-style: none;
    }
    .nav-links a {
      color: var(--text);
      text-decoration: none;
      font-weight: 500;
      transition: all 0.3s;
      position: relative;
      padding: 0.5rem 1rem;
      border-radius: 0.5rem;
    }
    .nav-links a:hover {
      color: var(--accent);
      background: var(--glass);
    }
    .nav-links a.active {
      color: var(--accent);
      background: var(--glass);
    }
    .page {
      display: none;
      animation: fadeIn 0.5s ease-in-out;
    }
    .page.active {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 3rem 2rem;
    }
    .hero {
      text-align: center;
      margin-bottom: 3rem;
    }
    .hero h1 {
      font-size: 3.5rem;
      font-weight: 900;
      margin-bottom: 1rem;
      background: linear-gradient(135deg, var(--light) 0%, var(--accent) 50%, var(--primary) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      animation: gradient 3s ease-in-out infinite;
      background-size: 200%;
    }
    @keyframes gradient {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .hero p {
      font-size: 1.2rem;
      color: var(--text);
      opacity: 0.8;
      max-width: 600px;
      margin: 0 auto;
    }
    .game-wrapper {
      display: flex;
      gap: 3rem;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
    }
    .game-container {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 2rem;
      padding: 2rem;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
      position: relative;
      overflow: hidden;
    }
    .game-container::before {
      content: '';
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      background: linear-gradient(45deg, var(--accent), var(--primary), var(--secondary));
      border-radius: 2rem;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }
    .game-container:hover::before {
      opacity: 0.5;
    }
    #game {
      border-radius: 1rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      transition: transform 0.3s;
    }
    #game:hover {
      transform: scale(1.02);
    }
    .controls-panel {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      min-width: 350px;
      max-width: 400px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
      max-height: 90vh;
      overflow-y: auto;
    }
    .controls-panel::-webkit-scrollbar {
      width: 8px;
    }
    .controls-panel::-webkit-scrollbar-track {
      background: var(--darker);
      border-radius: 4px;
    }
    .controls-panel::-webkit-scrollbar-thumb {
      background: var(--primary);
      border-radius: 4px;
    }
    .controls-section {
      margin-bottom: 2rem;
    }
    .controls-section h3 {
      font-size: 1.2rem;
      margin-bottom: 1rem;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }
    .controls-section h3::before {
      content: '‚ö°';
      font-size: 1.5rem;
    }
    .button {
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      font-weight: 600;
      font-size: 1rem;
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      position: relative;
      overflow: hidden;
    }
    .button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.2);
      transition: left 0.5s;
    }
    .button:hover::before {
      left: 100%;
    }
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .button:active {
      transform: translateY(0);
    }
    .button.toggle-active {
      background: linear-gradient(135deg, var(--success) 0%, var(--accent) 100%);
      box-shadow: 0 8px 25px rgba(74, 222, 128, 0.45);
    }
    .manual-hint {
      font-size: 0.85rem;
      margin-top: 0.5rem;
      color: var(--light);
      opacity: 0.7;
      text-align: center;
    }
    .button.danger {
      background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
      box-shadow: 0 4px 15px rgba(239, 68, 68, 0.4);
    }
    .button.danger:hover {
      box-shadow: 0 6px 20px rgba(239, 68, 68, 0.6);
    }
    .speed-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      justify-content: center;
      margin: 1rem 0;
    }
    .speed-btn {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 0.2rem;
      padding: 0.8rem 1.2rem;
      min-width: 100px;
    }
    .speed-btn span {
      display: block;
    }
    .speed-display {
      background: var(--darker);
      padding: 0.8rem 1.5rem;
      border-radius: 0.8rem;
      min-width: 140px;
      text-align: center;
      font-weight: 600;
      border: 1px solid var(--primary);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.3);
    }
    .size-controls {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin: 1rem 0;
    }
    .size-slider {
      flex: 1;
      -webkit-appearance: none;
      height: 8px;
      background: var(--darker);
      border-radius: 4px;
      outline: none;
      position: relative;
    }
    .size-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
      transition: all 0.3s;
    }
    .size-slider::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
    }
    .select-control {
      width: 100%;
      padding: 0.6rem 0.8rem;
      background: var(--glass);
      border: 1px solid var(--glass-border);
      border-radius: 0.75rem;
      color: var(--text);
      font-weight: 500;
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .select-control:focus {
      outline: none;
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(240, 147, 251, 0.25);
    }
    .select-control option {
      background: var(--dark);
      color: var(--text);
    }
    .param-control {
      margin-bottom: 1.5rem;
    }
    .param-control label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--text);
    }
    .param-control label span {
      color: var(--accent);
      font-weight: 700;
      min-width: 40px;
      text-align: right;
    }
    .param-control small {
      display: block;
      margin-top: 0.3rem;
      color: var(--text);
      opacity: 0.6;
      font-size: 0.8rem;
    }
    .param-control .size-slider {
      width: 100%;
    }
    .status-display {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-top: 1rem;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    .status-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0.5rem 0;
      border-bottom: 1px solid var(--glass-border);
    }
    .status-item:last-child {
      border-bottom: none;
    }
    .status-label {
      color: var(--text);
      opacity: 0.8;
    }
    .status-value {
      font-weight: 600;
      color: var(--accent);
    }
    #statusMessages {
      background: var(--darker);
      border-radius: 1rem;
      padding: 1rem;
      margin-top: 1rem;
      min-height: 120px;
      border: 1px solid var(--glass-border);
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.3);
    }
    #statusMessages p {
      margin: 0.3rem 0;
      font-size: 0.9rem;
      opacity: 0.9;
    }
    #strategyStatus {
      color: var(--accent);
      font-weight: 600;
      font-size: 1rem;
    }
    .status-explanation {
      color: var(--text);
      opacity: 0.85;
      line-height: 1.4;
    }
    #hamStatus { color: #4ade80; }
    #loopStatus { color: #fbbf24; }
    #compactStatus { color: #f97316; }
    #compactStepStatus { color: #38bdf8; }
    .info-content {
      max-width: 800px;
      margin: 0 auto;
    }
    .info-section {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 2rem;
      margin-bottom: 2rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .info-section h2 {
      color: var(--accent);
      margin-bottom: 1rem;
      font-size: 1.8rem;
    }
    .info-section h3 {
      color: var(--primary);
      margin: 1.5rem 0 1rem;
    }
    .info-section p, .info-section li {
      line-height: 1.8;
      opacity: 0.9;
    }
    .info-section ul {
      list-style: none;
      padding-left: 0;
    }
    .info-section li {
      position: relative;
      padding-left: 2rem;
      margin-bottom: 0.5rem;
    }
    .info-section li::before {
      content: '‚Üí';
      position: absolute;
      left: 0;
      color: var(--accent);
      font-weight: bold;
    }
    .contact-content {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    .contact-card {
      background: var(--glass);
      backdrop-filter: blur(20px);
      border: 1px solid var(--glass-border);
      border-radius: 1.5rem;
      padding: 3rem;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
    }
    .contact-card h2 {
      color: var(--accent);
      margin-bottom: 2rem;
      font-size: 2rem;
    }
    .contact-info {
      font-size: 1.2rem;
      margin: 2rem 0;
    }
    .contact-email {
      display: inline-block;
      background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
      color: white;
      padding: 1rem 2rem;
      border-radius: 2rem;
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s;
      box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
      margin-top: 1rem;
    }
    .contact-email:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
    }
    .combo-preset {
      background: var(--darker);
      padding: 1.5rem;
      border-radius: 1rem;
      margin-top: 1rem;
      border: 1px solid var(--primary);
    }
    .combo-preset ul {
      margin-bottom: 1rem;
    }
    .combo-preset li {
      padding-left: 1.5rem;
      font-family: monospace;
      font-size: 1.1rem;
      color: var(--accent);
    }
    .load-preset {
      width: 100%;
      background: linear-gradient(135deg, var(--primary), var(--accent));
    }
    @media (max-width: 768px) {
      .nav-container {
        flex-direction: column;
        gap: 1rem;
      }
      .hero h1 {
        font-size: 2.5rem;
      }
      .game-wrapper {
        flex-direction: column;
      }
      .controls-panel {
        width: 100%;
        max-width: none;
        max-height: none;
      }
    }
  </style>
</head>
<body>
  <!-- Navigation -->
  <nav>
    <div class="nav-container">
      <div class="logo">Snake Simulation</div>
      <ul class="nav-links">
        <li><a href="#" class="nav-link active" data-page="game">Game</a></li>
        <li><a href="#" class="nav-link" data-page="guide">Guide</a></li>
        <li><a href="#" class="nav-link" data-page="facit">Presets</a></li>
        <li><a href="#" class="nav-link" data-page="contact">Contact</a></li>
      </ul>
    </div>
  </nav>
  <!-- Game Page -->
  <div id="game-page" class="page active">
    <div class="container">
      <div class="hero">
        <h1>Snake Simulation</h1>
        <p>Your goal is to find the best adjustments to complete the board</p>
        <p>Adjust Grid size for longer simulations</p>
      </div>
      <div class="game-wrapper">
        <div class="game-container">
          <canvas id="game" width="600" height="600"></canvas>
        </div>
        <div class="controls-panel">
          <div class="controls-section">
            <h3>Game Controls</h3>
            <div class="speed-controls">
              <button id="slowerBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">üêå</span>
                <span>Slower</span>
              </button>
              <div id="speedDisplay" class="speed-display">Speed: 100ms</div>
              <button id="fasterBtn" class="button speed-btn">
                <span style="font-size: 1.2rem;">‚ö°</span>
                <span>Faster</span>
              </button>
            </div>
            <div style="margin-top: 1rem; display:flex; gap:0.5rem; flex-wrap:wrap;">
              <button id="restartBtn" class="button danger" style="flex:1;">üîÑ Restart</button>
              <button id="pauseBtn" class="button" style="flex:1;">‚è∏ Pause</button>
            </div>
            <div style="margin-top: 0.8rem;">
              <button id="manualToggle" class="button" style="width: 100%;">üïπÔ∏è Try Manual Play</button>
              <p id="manualHint" class="manual-hint">Manual mode off ‚Äì AI is playing automatically.</p>
            </div>
          </div>
          <div class="controls-section">
            <h3>Grid Size</h3>
            <div class="param-control">
              <label>Columns (COLS): <span id="colsValue">20</span></label>
              <input type="range" id="colsSlider" class="size-slider" min="10" max="100" value="20" step="5">
            </div>
            <div class="param-control">
              <label>Rows (ROWS): <span id="rowsValue">20</span></label>
              <input type="range" id="rowsSlider" class="size-slider" min="10" max="100" value="20" step="5">
            </div>
            <small style="display: block; margin-top: -0.5rem; color: var(--warning); opacity: 0.8;">
              ‚ö°Changing grid size will restart the game
            </small>
          </div>
          <div class="controls-section">
            <h3>Canvas Size</h3>
            <div class="size-controls">
              <span>Small</span>
              <input type="range" id="sizeSlider" class="size-slider" min="300" max="800" value="400" step="50">
              <span>Large</span>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Parameters</h3>
            <div class="param-control">
              <label for="algoSelect">Algorithm</label>
              <select id="algoSelect" class="select-control">
                <option value="double" selected>Double DQN (dueling)</option>
                <option value="vanilla">Classic DQN</option>
              </select>
              <small>Switch between double DQN and vanilla DQN.</small>
            </div>
            <div class="param-control">
              <label>Endgame Threshold: <span id="endgameValue">20</span></label>
              <input type="range" id="endgameSlider" class="size-slider" min="0" max="100" value="20" step="5">
              <small>Free cells for endgame mode</small>
            </div>
            <div class="param-control">
              <label>Loop Streak Threshold: <span id="loopThreshValue">3</span></label>
              <input type="range" id="loopThreshSlider" class="size-slider" min="1" max="10" value="3" step="1">
              <small>Loops detected before ‚Üí safety strategy</small>
            </div>
            <div class="param-control">
              <label>No Progress Threshold: <span id="progThreshValue">70</span></label>
              <input type="range" id="progThreshSlider" class="size-slider" min="10" max="200" value="70" step="5">
              <small>Moves without progress before penalty</small>
            </div>
            <div class="param-control">
              <label for="compactProfile">Compact Mode Stil</label>
              <select id="compactProfile" class="select-control">
                <option value="cautious">Extremt f√∂rsiktig</option>
                <option value="balanced" selected>Balanserad (nuvarande)</option>
                <option value="risky">Extremt v√•ghalsig</option>
              </select>
              <small id="compactProfileHint">Standardbeteende som reagerar p√• fickor eller loopar.</small>
            </div>
            <div class="param-control">
              <label>Compact Mode Steps: <span id="compactValue">200</span></label>
              <input type="range" id="compactSlider" class="size-slider" min="0" max="300" value="200" step="10">
              <small>Max steps in compact mode</small>
            </div>
          </div>
          <div class="controls-section">
            <h3>Game Status</h3>
            <div class="status-display">
              <div class="status-item">
                <span class="status-label">Length:</span>
                <span id="snakeLength" class="status-value">3</span>
              </div>
              <div class="status-item">
                <span class="status-label">Free cells:</span>
                <span id="freeCells" class="status-value">222</span>
              </div>
              <div class="status-item">
                <span class="status-label">Progress:</span>
                <span id="progress" class="status-value">1.3%</span>
              </div>
              <div class="status-item">
                <span class="status-label">Episodes:</span>
                <span id="episodeCount" class="status-value">0</span>
              </div>
              <div class="status-item">
                <span class="status-label">Best length:</span>
                <span id="bestLength" class="status-value">3</span>
              </div>
              <div class="status-item">
                <span class="status-label">Epsilon:</span>
                <span id="epsilonValue" class="status-value">1.00</span>
              </div>
            </div>
          </div>
          <div class="controls-section">
            <h3>AI Status</h3>
            <div id="statusMessages">
              <p id="strategyStatus">Strategy: Initializing</p>
              <p id="strategyExplanation" class="status-explanation"></p>
              <p id="hamStatus"></p>
              <p id="loopStatus"></p>
              <p id="compactStatus"></p>
              <p id="compactStepStatus"></p>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Guide Page -->
  <div id="guide-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Parameter Guide</h1>
        <p>Learn to fine-tune the AI for optimal performance</p>
      </div>
      <div class="info-content">
        <div class="info-section">
          <h2>üéØ Quick Guide</h2>
          <p>Each parameter affects how cautious or aggressive the AI is. Start by adjusting <strong>Endgame Threshold</strong>, as it has the biggest impact on whether the snake plays safely or takes risks. Find the balance between speed and safety!</p>
        </div>
        <div class="info-section">
          <h2>üìè Grid Size</h2>
          <h3>Columns &amp; Rows (10-60)</h3>
          <p><strong>What it does:</strong> Determines the game size - number of cells horizontally and vertically.</p>
          <ul>
            <li><strong>Small grids (10x10):</strong> Fast games, AI must be very careful</li>
            <li><strong>Medium (20x20):</strong> Balanced gameplay, standard setting</li>
            <li><strong>Large (30x30):</strong> Long games requiring patience, AI can take more risks</li>
          </ul>
          <p><strong>Tip:</strong> Start with 10x10 to learn the parameters.</p>
        </div>
        <div class="info-section">
          <h2>ü§ñ AI Parameters</h2>
          <h3>1. Endgame Threshold (5-100+)</h3>
          <p><strong>Why it matters most:</strong> This setting determines when the AI abandons risky fruit-hunting and switches to a safe Hamilton-inspired safety strategy. A lower value means the AI will stay aggressive until there are very few free cells left; a higher value makes it switch earlier.</p>
          <p><strong>What it does:</strong> When the number of free cells remaining drops below this threshold, the AI enters "endgame" mode. The reward shaper then favours survival, encouraging the agent to avoid risky moves while the board is tight.</p>
          <ul>
            <li><strong>Low value (10-30):</strong> Endgame only at the very end ‚Äì faster but riskier on tight grids</li>
            <li><strong>Medium (40-60):</strong> Safer and suitable for medium grids</li>
            <li><strong>High (70+):</strong> Very cautious ‚Äì ideal for large boards or when you want maximum safety</li>
          </ul>
          <h3>2. Loop Streak Threshold (1-10)</h3>
          <p><strong>What it does:</strong> Number of times the AI can detect a looping pattern before safety shaping kicks in. Loop penalties push the agent to diversify paths when the head repeats locations too often.</p>
          <ul>
            <li><strong>Low value (1-3):</strong> Quickly switches to safe behaviour, good for small grids</li>
            <li><strong>Medium (4-6):</strong> Balanced, allows some loops</li>
            <li><strong>High (7-10):</strong> Allows many loops, risky but faster on open boards</li>
          </ul>
          <h3>3. No Progress Threshold (10-200+)</h3>
          <p><strong>What it does:</strong> Number of moves without getting closer to the fruit before the AI applies a stagnation penalty. This helps the network learn that wandering without progress is costly.</p>
          <ul>
            <li><strong>Low value (10-50):</strong> Gives up quickly, very safe but slower on large boards</li>
            <li><strong>Medium (50-100):</strong> Standard patience</li>
            <li><strong>High (100+):</strong> Persistent, keeps trying for a long time</li>
          </ul>
          <h3>4. Compact Mode Steps (50-300+)</h3>
          <p><strong>What it does:</strong> Maximum number of steps the AI can spend in compact zig-zag mode when the fruit is trapped in a small pocket. This keeps the snake alive in tight spaces.</p>
          <ul>
            <li><strong>Low value (50-100):</strong> Short zig-zag, switches quickly back to other strategies</li>
            <li><strong>Medium (100-200):</strong> Standard length</li>
            <li><strong>High (200+):</strong> Long zig-zag sequences ‚Äì useful on large boards</li>
          </ul>
          <h3>Compact Mode Stil</h3>
          <ul>
            <li><strong>Extremt f√∂rsiktig:</strong> Kr√§ver tr√•nga fickor och upprepade loopar innan zig-zag anv√§nds.</li>
            <li><strong>Balanserad:</strong> Originalbeteendet ‚Äì reagerar p√• fickor eller tydliga loopar.</li>
            <li><strong>Extremt v√•ghalsig:</strong> Hoppar in tidigt f√∂r att reda ut loopar eller sv√•rtillg√§nglig frukt.</li>
          </ul>
          <p><strong>Tips:</strong> V√§lj en f√∂rsiktig stil p√• sm√• br√§den d√§r varje cell r√§knas, och en v√•ghalsig stil p√• stora br√§den f√∂r snabbare √•terh√§mtning.</p>
        </div>
        <div class="info-section">
          <h2>‚ö° Optimization Strategy</h2>
          <h3>For fastest possible game:</h3>
          <ul>
            <li>Loop Threshold: 5-7</li>
            <li>No Progress: 80-120</li>
            <li>Endgame: 5-30</li>
            <li>Compact Steps: 150-200</li>
          </ul>
          <h3>For safest possible game:</h3>
          <ul>
            <li>Loop Threshold: 1-2</li>
            <li>No Progress: 30-50</li>
            <li>Endgame: 60-80</li>
            <li>Compact Steps: 50-100</li>
          </ul>
          <h3>Balanced (recommended):</h3>
          <ul>
            <li>Loop Threshold: 3-4</li>
            <li>No Progress: 50-80</li>
            <li>Endgame: 40-50</li>
            <li>Compact Steps: 100-150</li>
          </ul>
        </div>
        <div class="info-section">
          <h2>üîç Algorithm Overview</h2>
          <h3>DQN family</h3>
          <p>The in-browser learner implements both classic DQN and double DQN with optional dueling heads. Experience replay and target networks run locally with TensorFlow.js, and the reward model integrates loop, stagnation, and compact-space shaping inspired by the heuristic agent.</p>
          <h3>Safety shaping</h3>
          <p>Loop streaks, stagnation counters, and compact mode cues are exposed to the network both as observation features and as auxiliary rewards. This mimics the behaviour of the handcrafted AI while allowing the neural policy to learn when to apply each behaviour.</p>
        </div>
      </div>
    </div>
  </div>
  <!-- Presets Page -->
  <div id="facit-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Presets - Proven Combinations</h1>
        <p>Test these optimized settings for different game types</p>
      </div>
      <div class="info-section">
        <h2>üêú Small Grid (10x10)</h2>
        <p><strong>Goal:</strong> Optimized for small, tight spaces</p>
        <div class="combo-preset">
          <ul>
            <li>Grid: 10x10</li>
            <li>Loop Threshold: 1</li>
            <li>No Progress: 30</li>
            <li>Endgame: 5</li>
            <li>Compact Steps: 50</li>
            <li>Speed: 120ms</li>
          </ul>
          <button class="button load-preset" data-preset="small">Load this</button>
        </div>
      </div>
      <div class="info-section">
        <h2>‚öñÔ∏è Balanced (20x20)</h2>
        <p><strong>Goal:</strong> Good balance between speed and safety</p>
        <div class="combo-preset">
          <ul>
            <li>Grid: 20x20</li>
            <li>Loop Threshold: 3</li>
            <li>No Progress: 70</li>
            <li>Endgame: 40</li>
            <li>Compact Steps: 200</li>
            <li>Speed: 80ms</li>
          </ul>
          <button class="button load-preset" data-preset="balanced">Load this</button>
        </div>
      </div>
      <div class="info-section">
        <h2>üéØ Ultra Challenge (30x30)</h2>
        <p><strong>Goal:</strong> For experts ‚Äì maximum grid with aggressive settings</p>
        <div class="combo-preset">
          <ul>
            <li>Grid: 30x30</li>
            <li>Loop Threshold: 5</li>
            <li>No Progress: 150</li>
            <li>Endgame: 80</li>
            <li>Compact Steps: 450</li>
            <li>Speed: 40ms</li>
          </ul>
          <button class="button load-preset" data-preset="ultra">Load this</button>
        </div>
      </div>
      <div class="info-section" style="background: var(--glass); border: 2px solid var(--accent);">
        <h2>üí° Tips for Custom Combinations</h2>
        <ul>
          <li><strong>Start conservatively:</strong> Set low thresholds and increase gradually</li>
          <li><strong>Test in stages:</strong> Run 5-10 games before adjusting</li>
          <li><strong>Document:</strong> Write down what works for different grid sizes</li>
          <li><strong>Experiment:</strong> Try extreme values to understand the effect</li>
          <li><strong>Share:</strong> Send us your best combinations!</li>
        </ul>
      </div>
    </div>
  </div>
  <!-- Contact Page -->
  <div id="contact-page" class="page">
    <div class="container">
      <div class="hero">
        <h1>Contact Me</h1>
        <p>Have questions or feedback?</p>
      </div>
      <div class="contact-content">
        <div class="contact-card">
          <h2>üì¨ Get in Touch</h2>
          <p class="contact-info"></p>
          <a href="mailto:nomarcus@hotmail.com" class="contact-email">‚úâÔ∏è nomarcus@hotmail.com</a>
          <p style="margin-top:2rem;font-size:.9rem;opacity:.7;text-align:center;">
            Last change by <strong>Marcus Petersson</strong> ¬∑ 2025-09-08
          </p>
        </div>
      </div>
    </div>
  </div>
  <script>
    const TF_SOURCES = [
      'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js',
      './node_modules/@tensorflow/tfjs/dist/tf.min.js'
    ];
    function ensureTfReady() {
      if (window.tf) return Promise.resolve(window.tf);
      if (!ensureTfReady.promise) {
        ensureTfReady.promise = (async () => {
          for (const src of TF_SOURCES) {
            try {
              await new Promise((resolve, reject) => {
                const existing = document.querySelector(`script[data-tfjs-src="${src}"]`);
                if (existing) {
                  if (window.tf) {
                    resolve();
                    return;
                  }
                  existing.addEventListener('load', () => resolve());
                  existing.addEventListener('error', () => reject(new Error(`Failed to load ${src}`)));
                  return;
                }
                const script = document.createElement('script');
                script.src = src;
                script.async = false;
                script.dataset.tfjsSrc = src;
                script.onload = () => {
                  script.dataset.tfjsLoaded = 'true';
                  resolve();
                };
                script.onerror = () => reject(new Error(`Failed to load ${src}`));
                document.head.appendChild(script);
              });
              if (window.tf) return window.tf;
            } catch (error) {
              console.warn(error);
            }
          }
          throw new Error('TensorFlow.js failed to load.');
        })();
      }
      return ensureTfReady.promise;
    }

  (async () => {
    try {
      await ensureTfReady();
    } catch (error) {
      console.error(error);
      const status = document.getElementById('statusMessages');
      if (status) {
        status.innerHTML = '<p style="color:#ef4444;font-weight:600;">Kunde inte ladda TensorFlow.js. Kontrollera din internetanslutning eller installera beroenden lokalt.</p>';
      }
      return;
    }

    const tf = window.tf;
    if (!tf) {
      console.error('TensorFlow.js loaded but global tf object is missing.');
      const status = document.getElementById('statusMessages');
      if (status) {
        status.innerHTML = '<p style="color:#ef4444;font-weight:600;">TensorFlow.js kunde inte initialiseras.</p>';
      }
      return;
    }

    const ACTIONS = [
      { dx: 0, dy: -1 },
      { dx: 0, dy: 1 },
      { dx: -1, dy: 0 },
      { dx: 1, dy: 0 },
    ];
    const DEFAULT_PARAMS = {
      endgameThreshold: 20,
      loopThreshold: 3,
      noProgressThreshold: 70,
      compactProfile: 'balanced',
      compactMaxSteps: 200,
    };
    const COMPACT_PROFILES = {
      cautious: {
        label: 'Extremt f√∂rsiktig',
        hint: 'Aktiveras f√∂rst n√§r frukten sitter tr√•ngt och loopen bekr√§ftas.',
        minFreeCells: 8,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: true,
        minLoopStreak: 2,
        allowCrowding: false,
      },
      balanced: {
        label: 'Balanserad (nuvarande)',
        hint: 'Originalbeteende ‚Äì reagerar p√• fickor eller tydliga loopar.',
        minFreeCells: 15,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 1,
        allowCrowding: false,
      },
      risky: {
        label: 'Extremt v√•ghalsig',
        hint: 'Hoppar in tidigt √§ven vid antydan till tr√§ngsel eller sv√•r frukt.',
        minFreeCells: 0,
        allowPocket: true,
        allowLoop: true,
        requirePocketWithLoop: false,
        minLoopStreak: 0,
        allowCrowding: true,
      },
    };
    const randomChoice = arr => arr[Math.floor(Math.random() * arr.length)];
    const clamp = (val, min, max) => Math.min(max, Math.max(min, val));

    class ReplayBuffer {
      constructor(capacity) {
        this.capacity = capacity;
        this.buffer = new Array(capacity);
        this.position = 0;
        this.size = 0;
      }
      add(state, action, reward, nextState, done) {
        this.buffer[this.position] = {
          state: Float32Array.from(state),
          action,
          reward,
          nextState: Float32Array.from(nextState),
          done,
        };
        this.position = (this.position + 1) % this.capacity;
        if (this.size < this.capacity) this.size++;
      }
      sample(batchSize) {
        const out = [];
        for (let i = 0; i < batchSize; i++) {
          const idx = Math.floor(Math.random() * this.size);
          out.push(this.buffer[idx]);
        }
        return out;
      }
      get length() {
        return this.size;
      }
      clear() {
        this.position = 0;
        this.size = 0;
      }
    }

    class DuelingMergeLayer extends tf.layers.Layer {
      constructor(config) {
        super(config);
        this.actionDim = config.actionDim;
      }
      computeOutputShape(inputShape) {
        return [inputShape[0][0], this.actionDim];
      }
      call(inputs) {
        const [value, advantage] = inputs;
        const mean = advantage.mean(-1, true);
        const centered = advantage.sub(mean);
        const tiledValue = value.tile([1, this.actionDim]);
        return tiledValue.add(centered);
      }
      static get className() {
        return 'DuelingMergeLayer';
      }
    }
    tf.serialization.registerClass(DuelingMergeLayer);

    class DQNAgent {
      constructor(stateDim, actionDim, cfg = {}) {
        this.stateDim = stateDim;
        this.actionDim = actionDim;
        this.gamma = cfg.gamma ?? 0.985;
        this.lr = cfg.lr ?? 0.00045;
        this.batchSize = cfg.batchSize ?? 128;
        this.buffer = new ReplayBuffer(cfg.bufferSize ?? 60000);
        this.epsilonStart = cfg.epsilonStart ?? 1.0;
        this.epsilonEnd = cfg.epsilonEnd ?? 0.08;
        this.epsilonDecay = cfg.epsilonDecay ?? 90000;
        this.epsilon = this.epsilonStart;
        this.learnEvery = cfg.learnEvery ?? 4;
        this.targetUpdate = cfg.targetUpdate ?? 2500;
        this.layers = Array.isArray(cfg.layers) ? cfg.layers.slice() : [256, 256, 128];
        this.double = cfg.double ?? true;
        this.dueling = cfg.dueling ?? true;
        this.totalSteps = 0;
        this.trainStep = 0;
        this.online = this.buildModel();
        this.target = this.buildModel();
        this.syncTarget();
        this.optimizer = tf.train.adam(this.lr);
        this.episodeRewards = [];
      }
      buildModel() {
        const input = tf.input({ shape: [this.stateDim] });
        let x = input;
        for (const units of this.layers) {
          x = tf.layers.dense({
            units,
            activation: 'relu',
            kernelInitializer: tf.initializers.heUniform(),
          }).apply(x);
        }
        let output;
        if (this.dueling) {
          const value = tf.layers
            .dense({ units: 1, activation: 'linear', kernelInitializer: 'glorotUniform' })
            .apply(x);
          const advantage = tf.layers
            .dense({ units: this.actionDim, activation: 'linear', kernelInitializer: 'glorotUniform' })
            .apply(x);
          output = new DuelingMergeLayer({ actionDim: this.actionDim }).apply([value, advantage]);
        } else {
          output = tf.layers.dense({ units: this.actionDim, activation: 'linear', kernelInitializer: 'glorotUniform' }).apply(x);
        }
        return tf.model({ inputs: input, outputs: output });
      }
      syncTarget() {
        const weights = this.online.getWeights();
        this.target.setWeights(weights);
      }
      act(state) {
        if (Math.random() < this.epsilon) {
          return Math.floor(Math.random() * this.actionDim);
        }
        return tf.tidy(() => {
          const input = tf.tensor2d(state, [1, this.stateDim]);
          const qValues = this.online.predict(input);
          const action = qValues.argMax(-1).dataSync()[0];
          qValues.dispose();
          input.dispose();
          return action;
        });
      }
      remember(state, action, reward, nextState, done) {
        this.buffer.add(state, action, reward, nextState, done);
        this.totalSteps++;
      }
      updateEpsilon() {
        if (this.totalSteps >= this.epsilonDecay) {
          this.epsilon = this.epsilonEnd;
        } else {
          const progress = this.totalSteps / this.epsilonDecay;
          this.epsilon = this.epsilonStart + (this.epsilonEnd - this.epsilonStart) * progress;
        }
        this.epsilon = clamp(this.epsilon, this.epsilonEnd, this.epsilonStart);
        return this.epsilon;
      }
      learn() {
        if (this.buffer.length < this.batchSize) return null;
        this.trainStep++;
        if (this.trainStep % this.learnEvery !== 0) return null;

        const batch = this.buffer.sample(this.batchSize);
        const states = tf.tensor2d(batch.map(t => Array.from(t.state)), [this.batchSize, this.stateDim]);
        const nextStates = tf.tensor2d(batch.map(t => Array.from(t.nextState)), [this.batchSize, this.stateDim]);
        const actions = tf.tensor1d(batch.map(t => t.action), 'int32');
        const rewards = tf.tensor1d(batch.map(t => t.reward));
        const dones = tf.tensor1d(batch.map(t => t.done ? 1 : 0));
        const actionMask = tf.oneHot(actions, this.actionDim);

        const { value, grads } = tf.variableGrads(() => {
          return tf.tidy(() => {
            const qValues = this.online.apply(states);
            const qSelected = qValues.mul(actionMask).sum(-1);

            const nextOnline = this.online.apply(nextStates);
            const nextTarget = this.target.apply(nextStates);
            let nextQ;
            if (this.double) {
              const nextBest = nextOnline.argMax(-1);
              const nextMask = tf.oneHot(nextBest, this.actionDim);
              nextQ = nextTarget.mul(nextMask).sum(-1);
              nextBest.dispose();
              nextMask.dispose();
            } else {
              nextQ = nextTarget.max(-1);
            }
            const notDone = tf.onesLike(dones).sub(dones);
            const discounted = nextQ.mul(this.gamma).mul(notDone);
            const target = rewards.add(discounted);

            const diff = target.sub(qSelected);
            const absDiff = diff.abs();
            const quadratic = absDiff.minimum(tf.scalar(1));
            const linear = absDiff.sub(quadratic);
            const loss = quadratic.square().mul(0.5).add(linear).mean();

            diff.dispose();
            absDiff.dispose();
            quadratic.dispose();
            linear.dispose();
            notDone.dispose();
            target.dispose();
            nextQ.dispose();
            nextTarget.dispose();
            nextOnline.dispose();
            qValues.dispose();
            return loss;
          });
        });

        this.optimizer.applyGradients(grads);
        const lossValue = value.dataSync()[0];
        value.dispose();
        Object.values(grads).forEach(g => g.dispose());
        states.dispose();
        nextStates.dispose();
        actions.dispose();
        rewards.dispose();
        dones.dispose();
        actionMask.dispose();

        if (this.trainStep % this.targetUpdate === 0) {
          this.syncTarget();
        }
        return lossValue;
      }
      onEpisodeEnd(totalReward) {
        this.episodeRewards.push(totalReward);
        if (this.episodeRewards.length > 200) this.episodeRewards.shift();
      }
      dispose() {
        this.online.dispose();
        this.target.dispose();
        this.optimizer.dispose();
      }
    }
    class SnakeGame {
      constructor(cols, rows, params = {}) {
        this.cols = cols;
        this.rows = rows;
        this.configure(params);
        this.reset();
      }
      configure(params = {}) {
        this.params = { ...DEFAULT_PARAMS, ...params };
        this.compactProfile = COMPACT_PROFILES[this.params.compactProfile] ? this.params.compactProfile : 'balanced';
        this.loopWindow = Math.max(8, Math.floor((this.cols + this.rows) / 2));
      }
      reset() {
        this.alive = true;
        this.steps = 0;
        this.loopStreak = 0;
        this.loopHits = 0;
        this.noProgressMoves = 0;
        this.compactMode = false;
        this.compactSteps = 0;
        this.prevDistance = Infinity;
        this.lastSpaceRatio = 1;
        this.stepsSinceFruit = 0;
        const startX = Math.floor(this.cols / 2);
        const startY = Math.floor(this.rows / 2);
        const length = Math.max(3, Math.min(5, Math.floor(this.cols / 2)));
        this.snake = [];
        for (let i = 0; i < length; i++) {
          this.snake.push({ x: startX - i, y: startY });
        }
        this.dir = { dx: 1, dy: 0 };
        this.snakeSet = new Set(this.snake.map(seg => `${seg.x},${seg.y}`));
        this.headHistory = [];
        this.spawnFruit();
        this.statusCache = this.buildStatus();
        return this.getObservation();
      }
      spawnFruit() {
        const free = [];
        for (let y = 0; y < this.rows; y++) {
          for (let x = 0; x < this.cols; x++) {
            if (!this.snakeSet.has(`${x},${y}`)) free.push({ x, y });
          }
        }
        this.fruit = free.length ? randomChoice(free) : { x: -1, y: -1 };
        this.prevDistance = this.fruit.x >= 0 ? this.manhattan(this.snake[0], this.fruit) : Infinity;
      }
      manhattan(a, b) {
        return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
      }
      freeSpaceFrom(sx, sy, allowTailMove) {
        const seen = new Set();
        const queue = [{ x: sx, y: sy }];
        const blocked = new Set(this.snakeSet);
        if (allowTailMove && this.snake.length) {
          const tail = this.snake[this.snake.length - 1];
          blocked.delete(`${tail.x},${tail.y}`);
        }
        while (queue.length) {
          const point = queue.shift();
          const key = `${point.x},${point.y}`;
          if (seen.has(key) || blocked.has(key)) continue;
          seen.add(key);
          for (const move of ACTIONS) {
            const nx = point.x + move.dx;
            const ny = point.y + move.dy;
            if (nx >= 0 && nx < this.cols && ny >= 0 && ny < this.rows) {
              queue.push({ x: nx, y: ny });
            }
          }
        }
        return seen.size;
      }
      isFruitInPocket() {
        if (!this.fruit || this.fruit.x < 0) return false;
        let blocked = 0;
        for (const move of ACTIONS) {
          const nx = this.fruit.x + move.dx;
          const ny = this.fruit.y + move.dy;
          if (nx < 0 || nx >= this.cols || ny < 0 || ny >= this.rows) blocked++;
          else if (this.snakeSet.has(`${nx},${ny}`)) blocked++;
        }
        return blocked >= 3;
      }
      isFruitAccessible() {
        if (!this.fruit || this.fruit.x < 0) return false;
        const head = this.snake[0];
        const visited = new Set([`${head.x},${head.y}`]);
        const queue = [head];
        while (queue.length) {
          const point = queue.shift();
          if (point.x === this.fruit.x && point.y === this.fruit.y) return true;
          for (const move of ACTIONS) {
            const nx = point.x + move.dx;
            const ny = point.y + move.dy;
            if (nx < 0 || nx >= this.cols || ny < 0 || ny >= this.rows) continue;
            const key = `${nx},${ny}`;
            if (visited.has(key)) continue;
            const tail = this.snake[this.snake.length - 1];
            const isTail = tail.x === nx && tail.y === ny;
            if (this.snakeSet.has(key) && !isTail) continue;
            visited.add(key);
            queue.push({ x: nx, y: ny });
          }
        }
        return false;
      }
      shouldEnterCompact(spaceRatio, fruitInPocket, fruitAccessible) {
        const profile = COMPACT_PROFILES[this.compactProfile] || COMPACT_PROFILES.balanced;
        if (this.compactMode) return true;
        if (this.snake.length >= this.cols * this.rows) return false;
        const freeCells = this.cols * this.rows - this.snake.length;
        if (freeCells <= profile.minFreeCells) return false;
        const loopReady = this.loopStreak >= Math.max(profile.minLoopStreak, 1);
        if (profile.allowPocket && fruitInPocket) {
          if (profile.requirePocketWithLoop && !loopReady) return false;
          return true;
        }
        if (profile.allowLoop && loopReady) return true;
        if (profile.allowCrowding && !fruitAccessible && spaceRatio < 0.35) return true;
        return false;
      }
      step(action) {
        if (!this.alive) {
          return { nextState: this.getObservation(), reward: 0, done: true, ateFruit: false, info: this.statusCache };
        }
        const move = ACTIONS[action] || ACTIONS[3];
        this.dir = { dx: move.dx, dy: move.dy };
        const head = this.snake[0];
        const next = { x: head.x + move.dx, y: head.y + move.dy };
        const willGrow = next.x === this.fruit.x && next.y === this.fruit.y;
        const hitsWall = next.x < 0 || next.x >= this.cols || next.y < 0 || next.y >= this.rows;
        const tail = this.snake[this.snake.length - 1];
        const tailKey = `${tail.x},${tail.y}`;
        const nextKey = `${next.x},${next.y}`;
        const hitsBody = !willGrow && this.snakeSet.has(nextKey) && !(tailKey === nextKey && !willGrow);
        let reward = -0.01;
        let done = false;
        let ateFruit = false;

        if (hitsWall || hitsBody) {
          reward -= 1.0;
          this.alive = false;
          done = true;
          this.statusCache = this.buildStatus({ crash: hitsWall ? 'wall' : 'self' });
          return { nextState: this.getObservation(), reward, done: true, ateFruit: false, info: this.statusCache };
        }

        this.snake.unshift(next);
        this.snakeSet.add(nextKey);
        this.headHistory.push(nextKey);
        if (this.headHistory.length > this.loopWindow) this.headHistory.shift();

        const uniqueCount = new Set(this.headHistory).size;
        const loopDetected = uniqueCount <= this.headHistory.length - 2;
        if (loopDetected) {
          this.loopStreak = Math.min(this.loopStreak + 1, 999);
          this.loopHits++;
        } else {
          this.loopStreak = Math.max(0, this.loopStreak - 1);
        }

        if (willGrow) {
          ateFruit = true;
          reward += 1.0;
          this.spawnFruit();
          this.stepsSinceFruit = 0;
        } else {
          const removed = this.snake.pop();
          this.snakeSet.delete(`${removed.x},${removed.y}`);
          this.stepsSinceFruit++;
        }

        const fruitDistance = this.fruit.x >= 0 ? this.manhattan(this.snake[0], this.fruit) : 0;
        if (fruitDistance < this.prevDistance) {
          reward += 0.02;
          this.noProgressMoves = 0;
        } else {
          reward -= 0.02;
          this.noProgressMoves++;
        }
        this.prevDistance = fruitDistance;

        const freeSpace = this.freeSpaceFrom(this.snake[0].x, this.snake[0].y, !willGrow);
        const totalCells = this.cols * this.rows;
        this.lastSpaceRatio = totalCells > 0 ? Math.min(1, freeSpace / totalCells) : 0;
        const endgameActive = (totalCells - this.snake.length) <= this.params.endgameThreshold;
        if (endgameActive) {
          reward += 0.01;
        }
        if (this.loopStreak >= this.params.loopThreshold) {
          reward -= 0.05;
        }
        if (this.noProgressMoves >= this.params.noProgressThreshold) {
          reward -= 0.05;
        }

        const fruitInPocket = this.isFruitInPocket();
        const fruitAccessible = this.isFruitAccessible();
        if (this.shouldEnterCompact(this.lastSpaceRatio, fruitInPocket, fruitAccessible)) {
          if (!this.compactMode) {
            this.compactMode = true;
            this.compactSteps = 0;
          }
        }
        if (this.compactMode) {
          reward += 0.005;
          this.compactSteps++;
          if (this.compactSteps >= this.params.compactMaxSteps) {
            this.compactMode = false;
            this.compactSteps = 0;
          }
        }

        if (this.snake.length === totalCells) {
          reward += 5.0;
          done = true;
          this.alive = false;
        }

        this.steps++;
        this.statusCache = this.buildStatus();
        return { nextState: this.getObservation(), reward, done, ateFruit, info: this.statusCache };
      }
      getObservation() {
        const head = this.snake[0];
        const forward = this.dir;
        const left = { dx: -forward.dy, dy: forward.dx };
        const right = { dx: forward.dy, dy: -forward.dx };
        const block = ({ dx, dy }) => {
          const nx = head.x + dx;
          const ny = head.y + dy;
          if (nx < 0 || nx >= this.cols || ny < 0 || ny >= this.rows) return 1;
          return this.snakeSet.has(`${nx},${ny}`) ? 1 : 0;
        };
        const danger = [block(forward), block(left), block(right)];
        const dir = [
          forward.dy === -1 ? 1 : 0,
          forward.dy === 1 ? 1 : 0,
          forward.dx === -1 ? 1 : 0,
          forward.dx === 1 ? 1 : 0,
        ];
        const fruit = this.fruit.x >= 0 ? [
          this.fruit.y < head.y ? 1 : 0,
          this.fruit.y > head.y ? 1 : 0,
          this.fruit.x < head.x ? 1 : 0,
          this.fruit.x > head.x ? 1 : 0,
        ] : [0, 0, 0, 0];
        const dist = [
          head.y / Math.max(1, this.rows - 1),
          (this.rows - 1 - head.y) / Math.max(1, this.rows - 1),
          head.x / Math.max(1, this.cols - 1),
          (this.cols - 1 - head.x) / Math.max(1, this.cols - 1),
        ];
        const freeRatio = this.lastSpaceRatio ?? 1;
        const loopRatio = this.loopStreak / Math.max(1, this.params.loopThreshold);
        const progressRatio = this.noProgressMoves / Math.max(1, this.params.noProgressThreshold);
        const endgame = (this.cols * this.rows - this.snake.length) <= this.params.endgameThreshold ? 1 : 0;
        const compact = this.compactMode ? 1 : 0;
        return Float32Array.from([
          ...danger,
          ...dir,
          ...fruit,
          ...dist,
          freeRatio,
          loopRatio,
          progressRatio,
          endgame,
          compact,
        ]);
      }
      buildStatus(extra = {}) {
        const totalCells = this.cols * this.rows;
        const freeCells = totalCells - this.snake.length;
        const endgameActive = freeCells <= this.params.endgameThreshold;
        let strategy = 'Greedy fruit chase';
        let explanation = 'Agent prioritises collecting fruit while staying safe.';
        if (!this.alive) {
          strategy = 'Game over';
          explanation = extra.crash === 'wall' ? 'Collision with wall ended the episode.' : 'Collision with body ended the episode.';
        } else if (this.compactMode) {
          strategy = 'Compact zig-zag';
          explanation = 'Tight zig-zag beteende h√•ller utrymmet √∂ppet runt frukten.';
        } else if (this.loopStreak >= this.params.loopThreshold) {
          strategy = 'Loop recovery';
          explanation = 'Loop-penalty aktiverad ‚Äì agenten s√∂ker en ny rutt.';
        } else if (this.noProgressMoves >= this.params.noProgressThreshold) {
          strategy = 'Searching for fruit';
          explanation = 'Stagnationsstraffet uppmuntrar nya v√§gar mot frukten.';
        } else if (endgameActive) {
          strategy = 'Endgame safety';
          explanation = 'Br√§det √§r tr√•ngt. Bel√∂ningsmodellen premierar √∂verlevnad.';
        }
        const profile = COMPACT_PROFILES[this.compactProfile] || COMPACT_PROFILES.balanced;
        return {
          snakeLength: this.snake.length,
          freeCells,
          progress: totalCells > 0 ? this.snake.length / totalCells : 0,
          loopStreak: this.loopStreak,
          loopThreshold: this.params.loopThreshold,
          loopDetected: this.loopStreak >= this.params.loopThreshold,
          noProgress: this.noProgressMoves,
          noProgressThreshold: this.params.noProgressThreshold,
          endgameActive,
          compactMode: this.compactMode,
          compactStep: this.compactSteps,
          compactMax: this.params.compactMaxSteps,
          compactProfile: profile.label,
          strategy,
          explanation,
          spaceRatio: this.lastSpaceRatio,
        };
      }
    }
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    let COLS = 20;
    let ROWS = 20;
    let CELL = canvas.width / COLS;
    let SPEED = 100;
    const MIN_SPEED = 10;
    const MAX_SPEED = 500;
    const SPEED_STEP = 10;

    let env = null;
    let agent = null;
    let currentState = null;
    let lastRender = performance.now();
    let eatParticles = [];
    let intervalHandle = null;
    let paused = false;
    let manualMode = false;
    let manualDirection = { dx: 1, dy: 0 };
    let pendingManualDirection = null;
    let totalEpisodes = 0;
    let bestLength = 3;
    let episodeReward = 0;
    let lastLoss = null;
    let loadingPreset = false;
    let currentAlgorithm = 'double';

    const ui = {
      navLinks: Array.from(document.querySelectorAll('.nav-link')),
      pages: Array.from(document.querySelectorAll('.page')),
      slowerBtn: document.getElementById('slowerBtn'),
      fasterBtn: document.getElementById('fasterBtn'),
      restartBtn: document.getElementById('restartBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      manualToggle: document.getElementById('manualToggle'),
      manualHint: document.getElementById('manualHint'),
      speedDisplay: document.getElementById('speedDisplay'),
      colsSlider: document.getElementById('colsSlider'),
      rowsSlider: document.getElementById('rowsSlider'),
      colsValue: document.getElementById('colsValue'),
      rowsValue: document.getElementById('rowsValue'),
      sizeSlider: document.getElementById('sizeSlider'),
      algoSelect: document.getElementById('algoSelect'),
      endgameSlider: document.getElementById('endgameSlider'),
      endgameValue: document.getElementById('endgameValue'),
      loopThreshSlider: document.getElementById('loopThreshSlider'),
      loopThreshValue: document.getElementById('loopThreshValue'),
      progThreshSlider: document.getElementById('progThreshSlider'),
      progThreshValue: document.getElementById('progThreshValue'),
      compactSlider: document.getElementById('compactSlider'),
      compactValue: document.getElementById('compactValue'),
      compactProfile: document.getElementById('compactProfile'),
      compactProfileHint: document.getElementById('compactProfileHint'),
      snakeLength: document.getElementById('snakeLength'),
      freeCells: document.getElementById('freeCells'),
      progress: document.getElementById('progress'),
      episodeCount: document.getElementById('episodeCount'),
      bestLength: document.getElementById('bestLength'),
      epsilonValue: document.getElementById('epsilonValue'),
      strategyStatus: document.getElementById('strategyStatus'),
      strategyExplanation: document.getElementById('strategyExplanation'),
      hamStatus: document.getElementById('hamStatus'),
      loopStatus: document.getElementById('loopStatus'),
      compactStatus: document.getElementById('compactStatus'),
      compactStepStatus: document.getElementById('compactStepStatus'),
      presetButtons: Array.from(document.querySelectorAll('.load-preset')),
    };
    function getAgentConfig() {
      if (currentAlgorithm === 'vanilla') {
        return {
          gamma: 0.98,
          lr: 0.0003,
          batchSize: 96,
          bufferSize: 50000,
          epsilonStart: 1.0,
          epsilonEnd: 0.1,
          epsilonDecay: 75000,
          learnEvery: 4,
          targetUpdate: 2200,
          layers: [128, 128],
          double: false,
          dueling: false,
        };
      }
      return {
        gamma: 0.985,
        lr: 0.00045,
        batchSize: 128,
        bufferSize: 60000,
        epsilonStart: 1.0,
        epsilonEnd: 0.08,
        epsilonDecay: 90000,
        learnEvery: 4,
        targetUpdate: 2500,
        layers: [256, 256, 128],
        double: true,
        dueling: true,
      };
    }

    function createEnvironment() {
      env = new SnakeGame(COLS, ROWS, {
        endgameThreshold: parseInt(ui.endgameSlider.value, 10) || DEFAULT_PARAMS.endgameThreshold,
        loopThreshold: parseInt(ui.loopThreshSlider.value, 10) || DEFAULT_PARAMS.loopThreshold,
        noProgressThreshold: parseInt(ui.progThreshSlider.value, 10) || DEFAULT_PARAMS.noProgressThreshold,
        compactProfile: ui.compactProfile.value,
        compactMaxSteps: parseInt(ui.compactSlider.value, 10) || DEFAULT_PARAMS.compactMaxSteps,
      });
      bestLength = Math.max(3, env.snake.length);
      currentState = env.getObservation();
    }

    function createAgent() {
      const config = getAgentConfig();
      const stateDim = currentState.length;
      if (agent) agent.dispose();
      agent = new DQNAgent(stateDim, ACTIONS.length, config);
      lastLoss = null;
    }

    function startLoop() {
      if (intervalHandle) return;
      intervalHandle = setInterval(gameTick, SPEED);
    }

    function stopLoop() {
      if (!intervalHandle) return;
      clearInterval(intervalHandle);
      intervalHandle = null;
    }

    function togglePause() {
      paused = !paused;
      if (paused) {
        stopLoop();
        ui.pauseBtn.textContent = '‚ñ∂ Resume';
      } else {
        startLoop();
        ui.pauseBtn.textContent = '‚è∏ Pause';
      }
      updateManualUI();
    }
    function setManualMode(enabled) {
      manualMode = enabled;
      if (manualMode) {
        paused = false;
        ui.pauseBtn.textContent = '‚è∏ Pause';
        startLoop();
        if (env && env.snake.length > 1) {
          const head = env.snake[0];
          const neck = env.snake[1];
          manualDirection = { dx: head.x - neck.x, dy: head.y - neck.y };
        }
      } else {
        pendingManualDirection = null;
        currentState = env ? env.getObservation() : currentState;
        if (!paused) startLoop();
      }
      updateManualUI();
    }

    function toggleManualMode() {
      setManualMode(!manualMode);
    }

    function directionToAction(dir) {
      for (let i = 0; i < ACTIONS.length; i++) {
        if (ACTIONS[i].dx === dir.dx && ACTIONS[i].dy === dir.dy) return i;
      }
      return 3;
    }

    function setManualDirection(dx, dy) {
      const current = pendingManualDirection || manualDirection;
      if (current.dx === -dx && current.dy === -dy) return;
      pendingManualDirection = { dx, dy };
    }

    function updateManualUI() {
      if (!ui.manualToggle || !ui.manualHint) return;
      if (manualMode) {
        ui.manualToggle.classList.add('toggle-active');
        ui.manualToggle.textContent = 'üß† Return to AI';
        ui.manualHint.textContent = 'Manual mode active! Use arrow keys or WASD to steer the snake.';
      } else {
        ui.manualToggle.classList.remove('toggle-active');
        ui.manualToggle.textContent = 'üïπÔ∏è Try Manual Play';
        ui.manualHint.textContent = paused ? 'Training paused. Press Resume to continue.' : 'Manual mode off ‚Äì AI is playing automatically.';
      }
    }
    function gameTick() {
      const now = performance.now();
      if (!env) return;
      if (manualMode) {
        const direction = pendingManualDirection || manualDirection;
        manualDirection = direction;
        pendingManualDirection = null;
        const action = directionToAction(direction);
        const result = env.step(action);
        currentState = result.nextState;
        if (result.ateFruit) {
          const head = env.snake[0];
          spawnEatEffect(head.x, head.y);
        }
        if (result.done) {
          stopLoop();
          paused = true;
          ui.pauseBtn.textContent = '‚ñ∂ Resume';
        }
        updateStatusUI(result.info);
        draw(result.ateFruit, now);
        return;
      }
      if (paused || !agent) return;

      const action = agent.act(currentState);
      const result = env.step(action);
      const nextState = result.nextState;
      agent.remember(currentState, action, result.reward, nextState, result.done);
      const loss = agent.learn();
      if (loss !== null && Number.isFinite(loss)) {
        lastLoss = loss;
      }
      agent.updateEpsilon();
      episodeReward += result.reward;
      currentState = nextState;
      if (result.ateFruit) {
        const head = env.snake[0];
        spawnEatEffect(head.x, head.y);
      }
      if (result.done) {
        agent.onEpisodeEnd(episodeReward);
        totalEpisodes++;
        bestLength = Math.max(bestLength, env.snake.length);
        episodeReward = 0;
        env.reset();
        currentState = env.getObservation();
      }
      updateStatusUI(result.info);
      draw(result.ateFruit, now);
    }

    function spawnEatEffect(cellX, cellY) {
      const originX = cellX * CELL + CELL / 2;
      const originY = cellY * CELL + CELL / 2;
      const count = Math.max(12, Math.floor(CELL / 1.8));
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = (Math.random() * 0.6 + 0.2) * CELL / 6;
        const lifetime = 1 + Math.random() * 0.6;
        eatParticles.push({
          x: originX,
          y: originY,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: lifetime,
          maxLife: lifetime,
          size: CELL * (0.12 + Math.random() * 0.12),
          hue: 200 + Math.random() * 40,
        });
      }
    }

    function updateParticles(delta) {
      const decay = delta / 1000;
      eatParticles = eatParticles.filter(p => {
        p.life -= decay;
        if (p.life <= 0) return false;
        p.x += p.vx * (delta / (1000 / 60));
        p.y += p.vy * (delta / (1000 / 60));
        p.vx *= 0.97;
        p.vy *= 0.97;
        return true;
      });
    }

    function draw(ate, now = performance.now()) {
      const delta = now - lastRender;
      lastRender = now;
      updateParticles(delta);
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
      gradient.addColorStop(0, '#1a1a2e');
      gradient.addColorStop(1, '#0f0f23');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      ctx.strokeStyle = 'rgba(255, 255, 255, 0.02)';
      ctx.lineWidth = 1;
      for (let i = 0; i <= COLS; i++) {
        ctx.beginPath();
        ctx.moveTo(i * CELL, 0);
        ctx.lineTo(i * CELL, canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i <= ROWS; i++) {
        ctx.beginPath();
        ctx.moveTo(0, i * CELL);
        ctx.lineTo(canvas.width, i * CELL);
        ctx.stroke();
      }

      if (env.fruit && env.fruit.x >= 0) {
        const centerX = env.fruit.x * CELL + CELL / 2;
        const centerY = env.fruit.y * CELL + CELL / 2;
        const radius = CELL / 2.6;
        const glow = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, CELL);
        glow.addColorStop(0, 'rgba(220, 38, 38, 0.5)');
        glow.addColorStop(1, 'transparent');
        ctx.fillStyle = glow;
        ctx.fillRect(env.fruit.x * CELL, env.fruit.y * CELL, CELL, CELL);
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fillStyle = '#d62828';
        ctx.fill();
        ctx.lineWidth = Math.max(2, CELL / 8);
        ctx.strokeStyle = '#111';
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.beginPath();
        ctx.arc(centerX - radius / 2.2, centerY - radius / 2.2, radius / 4, 0, Math.PI * 2);
        ctx.fill();
      }

      eatParticles.forEach(p => {
        const alpha = Math.max(0, p.life / p.maxLife);
        const flare = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
        flare.addColorStop(0, `hsla(${p.hue}, 90%, 80%, ${alpha * 0.85})`);
        flare.addColorStop(0.6, `hsla(${p.hue}, 90%, 65%, ${alpha * 0.45})`);
        flare.addColorStop(1, `hsla(${p.hue}, 90%, 40%, 0)`);
        ctx.fillStyle = flare;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
        ctx.fill();
      });

      const loopActive = env.loopStreak >= env.params.loopThreshold;
      const headColor = env.compactMode ? '#f97316' : loopActive ? '#fbbf24' : '#667eea';
      env.snake.forEach((seg, idx) => {
        const isHead = idx === 0;
        const size = CELL * 0.95;
        const offset = (CELL - size) / 2;
        const x = seg.x * CELL + offset;
        const y = seg.y * CELL + offset;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(x + 2, y + 2, size, size);
        const gradient = ctx.createLinearGradient(x, y, x + size, y + size);
        if (isHead) {
          gradient.addColorStop(0, headColor);
          gradient.addColorStop(1, env.compactMode ? '#ea580c' : loopActive ? '#f59e0b' : '#764ba2');
        } else {
          const t = idx / Math.max(1, env.snake.length - 1);
          const r = Math.round(102 + (138 - 102) * t);
          const g = Math.round(126 + (75 - 126) * t);
          const b = Math.round(234 + (162 - 234) * t);
          gradient.addColorStop(0, `rgb(${r}, ${g}, ${b})`);
          gradient.addColorStop(1, `rgb(${r - 30}, ${g - 30}, ${b - 30})`);
        }
        ctx.fillStyle = gradient;
        ctx.fillRect(x, y, size, size);
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(x, y, size, size / 3);
        if (isHead && env.snake.length > 1) {
          ctx.fillStyle = '#fff';
          const neck = env.snake[1];
          const dx = seg.x - neck.x;
          const dy = seg.y - neck.y;
          let eyeX1, eyeY1, eyeX2, eyeY2;
          if (dx === 1) {
            eyeX1 = x + size - size / 4;
            eyeY1 = y + size / 4;
            eyeX2 = x + size - size / 4;
            eyeY2 = y + size - size / 4;
          } else if (dx === -1) {
            eyeX1 = x + size / 4;
            eyeY1 = y + size / 4;
            eyeX2 = x + size / 4;
            eyeY2 = y + size - size / 4;
          } else if (dy === 1) {
            eyeX1 = x + size / 4;
            eyeY1 = y + size - size / 4;
            eyeX2 = x + size - size / 4;
            eyeY2 = y + size - size / 4;
          } else {
            eyeX1 = x + size / 4;
            eyeY1 = y + size / 4;
            eyeX2 = x + size - size / 4;
            eyeY2 = y + size / 4;
          }
          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, size / 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(eyeX2, eyeY2, size / 10, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(eyeX1, eyeY1, size / 20, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(eyeX2, eyeY2, size / 20, 0, Math.PI * 2);
          ctx.fill();
        }
      });
    }
    function getAlgorithmLabel() {
      return currentAlgorithm === 'vanilla' ? 'Classic DQN' : 'Double DQN';
    }

    function updateStatusUI(info) {
      if (!info) info = env ? env.buildStatus() : null;
      if (!info) return;
      const algorithmLabel = getAlgorithmLabel();
      ui.snakeLength.textContent = info.snakeLength;
      ui.freeCells.textContent = info.freeCells;
      ui.progress.textContent = `${(info.progress * 100).toFixed(1)}%`;
      ui.episodeCount.textContent = totalEpisodes;
      ui.bestLength.textContent = bestLength;
      const epsilon = agent ? agent.epsilon : 1;
      ui.epsilonValue.textContent = epsilon.toFixed(2);
      ui.strategyStatus.textContent = `Strategy: ${algorithmLabel} ‚Äì ${info.strategy}`;
      const extras = [];
      extras.push(`Episodes: ${totalEpisodes}`);
      extras.push(`Best length: ${bestLength}`);
      if (lastLoss !== null) extras.push(`Loss: ${lastLoss.toFixed(4)}`);
      ui.strategyExplanation.textContent = `${info.explanation} ${extras.join(' ¬∑ ')}`.trim();
      ui.hamStatus.textContent = info.endgameActive ? 'Endgame safety active.' : '';
      ui.loopStatus.textContent = info.loopDetected ? `Loop streak ${info.loopStreak}/${info.loopThreshold}` : '';
      ui.compactStatus.textContent = info.compactMode ? `Compact mode (${info.compactProfile}) engaged.` : '';
      ui.compactStepStatus.textContent = info.compactMode ? `Step ${info.compactStep} of ${info.compactMax}` : '';
    }

    function changeSpeed(value) {
      const next = clamp(value, MIN_SPEED, MAX_SPEED);
      if (next === SPEED) return;
      SPEED = next;
      ui.speedDisplay.textContent = `Speed: ${SPEED}ms`;
      if (intervalHandle) {
        stopLoop();
        startLoop();
      }
    }

    function applyGridSize(newSize) {
      const size = clamp(newSize, 10, 100);
      COLS = size;
      ROWS = size;
      ui.colsSlider.value = size;
      ui.rowsSlider.value = size;
      ui.colsValue.textContent = size;
      ui.rowsValue.textContent = size;
      CELL = canvas.width / COLS;
      hardReset(true);
    }

    function updateCanvasSize(size) {
      const s = clamp(size, 300, 800);
      canvas.width = s;
      canvas.height = s;
      CELL = canvas.width / COLS;
      draw(false, performance.now());
    }

    function hardReset(resetAgentToo) {
      stopLoop();
      if (env) env.configure({
        endgameThreshold: parseInt(ui.endgameSlider.value, 10) || DEFAULT_PARAMS.endgameThreshold,
        loopThreshold: parseInt(ui.loopThreshSlider.value, 10) || DEFAULT_PARAMS.loopThreshold,
        noProgressThreshold: parseInt(ui.progThreshSlider.value, 10) || DEFAULT_PARAMS.noProgressThreshold,
        compactProfile: ui.compactProfile.value,
        compactMaxSteps: parseInt(ui.compactSlider.value, 10) || DEFAULT_PARAMS.compactMaxSteps,
      });
      createEnvironment();
      if (resetAgentToo) {
        createAgent();
        totalEpisodes = 0;
        bestLength = env.snake.length;
        episodeReward = 0;
      } else {
        currentState = env.getObservation();
      }
      paused = false;
      ui.pauseBtn.textContent = '‚è∏ Pause';
      setManualMode(false);
      startLoop();
      updateStatusUI(env.buildStatus());
      draw(false, performance.now());
    }
    ui.navLinks.forEach(link => {
      link.addEventListener('click', evt => {
        evt.preventDefault();
        const targetPage = link.dataset.page;
        ui.navLinks.forEach(l => l.classList.remove('active'));
        link.classList.add('active');
        ui.pages.forEach(p => p.classList.remove('active'));
        const page = document.getElementById(`${targetPage}-page`);
        if (page) page.classList.add('active');
      });
    });

    ui.slowerBtn.addEventListener('click', () => changeSpeed(SPEED + SPEED_STEP));
    ui.fasterBtn.addEventListener('click', () => changeSpeed(SPEED - SPEED_STEP));
    ui.restartBtn.addEventListener('click', () => hardReset(true));
    ui.pauseBtn.addEventListener('click', togglePause);
    ui.manualToggle.addEventListener('click', toggleManualMode);

    ui.colsSlider.addEventListener('input', () => {
      if (loadingPreset) return;
      applyGridSize(parseInt(ui.colsSlider.value, 10));
    });
    ui.rowsSlider.addEventListener('input', () => {
      if (loadingPreset) return;
      applyGridSize(parseInt(ui.rowsSlider.value, 10));
    });
    ui.sizeSlider.addEventListener('input', () => updateCanvasSize(parseInt(ui.sizeSlider.value, 10)));

    ui.endgameSlider.addEventListener('input', () => {
      ui.endgameValue.textContent = ui.endgameSlider.value;
      if (env) env.params.endgameThreshold = parseInt(ui.endgameSlider.value, 10);
    });
    ui.loopThreshSlider.addEventListener('input', () => {
      ui.loopThreshValue.textContent = ui.loopThreshSlider.value;
      if (env) env.params.loopThreshold = parseInt(ui.loopThreshSlider.value, 10);
    });
    ui.progThreshSlider.addEventListener('input', () => {
      ui.progThreshValue.textContent = ui.progThreshSlider.value;
      if (env) env.params.noProgressThreshold = parseInt(ui.progThreshSlider.value, 10);
    });
    ui.compactSlider.addEventListener('input', () => {
      ui.compactValue.textContent = ui.compactSlider.value;
      if (env) env.params.compactMaxSteps = parseInt(ui.compactSlider.value, 10);
    });
    ui.compactProfile.addEventListener('change', () => {
      const profile = COMPACT_PROFILES[ui.compactProfile.value] || COMPACT_PROFILES.balanced;
      ui.compactProfileHint.textContent = profile.hint;
      if (env) env.compactProfile = ui.compactProfile.value;
    });

    ui.algoSelect.addEventListener('change', () => {
      currentAlgorithm = ui.algoSelect.value === 'vanilla' ? 'vanilla' : 'double';
      hardReset(true);
    });

    ui.presetButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        const preset = btn.dataset.preset;
        loadingPreset = true;
        if (preset === 'small') {
          ui.colsSlider.value = 10;
          ui.rowsSlider.value = 10;
          ui.loopThreshSlider.value = 1;
          ui.progThreshSlider.value = 30;
          ui.endgameSlider.value = 5;
          ui.compactSlider.value = 50;
          ui.compactProfile.value = 'cautious';
          changeSpeed(120);
        } else if (preset === 'balanced') {
          ui.colsSlider.value = 20;
          ui.rowsSlider.value = 20;
          ui.loopThreshSlider.value = 3;
          ui.progThreshSlider.value = 70;
          ui.endgameSlider.value = 40;
          ui.compactSlider.value = 200;
          ui.compactProfile.value = 'balanced';
          changeSpeed(80);
        } else if (preset === 'ultra') {
          ui.colsSlider.value = 30;
          ui.rowsSlider.value = 30;
          ui.loopThreshSlider.value = 5;
          ui.progThreshSlider.value = 150;
          ui.endgameSlider.value = 80;
          ui.compactSlider.value = 450;
          ui.compactProfile.value = 'risky';
          changeSpeed(40);
        }
        ui.loopThreshValue.textContent = ui.loopThreshSlider.value;
        ui.progThreshValue.textContent = ui.progThreshSlider.value;
        ui.endgameValue.textContent = ui.endgameSlider.value;
        ui.compactValue.textContent = ui.compactSlider.value;
        const profile = COMPACT_PROFILES[ui.compactProfile.value] || COMPACT_PROFILES.balanced;
        ui.compactProfileHint.textContent = profile.hint;
        loadingPreset = false;
        applyGridSize(parseInt(ui.colsSlider.value, 10));
      });
    });
    const KEY_TO_DIR = {
      arrowup: { dx: 0, dy: -1 },
      w: { dx: 0, dy: -1 },
      arrowdown: { dx: 0, dy: 1 },
      s: { dx: 0, dy: 1 },
      arrowleft: { dx: -1, dy: 0 },
      a: { dx: -1, dy: 0 },
      arrowright: { dx: 1, dy: 0 },
      d: { dx: 1, dy: 0 },
    };

    document.addEventListener('keydown', event => {
      if (!manualMode) return;
      const dir = KEY_TO_DIR[event.key.toLowerCase()];
      if (!dir) return;
      setManualDirection(dir.dx, dir.dy);
      event.preventDefault();
    });

    function init() {
      const profile = COMPACT_PROFILES[ui.compactProfile.value] || COMPACT_PROFILES.balanced;
      ui.compactProfileHint.textContent = profile.hint;
      ui.endgameValue.textContent = ui.endgameSlider.value;
      ui.loopThreshValue.textContent = ui.loopThreshSlider.value;
      ui.progThreshValue.textContent = ui.progThreshSlider.value;
      ui.compactValue.textContent = ui.compactSlider.value;
      ui.speedDisplay.textContent = `Speed: ${SPEED}ms`;
      createEnvironment();
      createAgent();
      startLoop();
      updateStatusUI(env.buildStatus());
      draw(false, performance.now());
    }

    init();
  })();
  </script>
</body>
</html>
