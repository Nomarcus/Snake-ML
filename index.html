<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake-ML ¬∑ Hybrid Max Mode (RL + BFS + Hamilton)</title>
<style>
  :root { --bg:#0b0e14; --panel:#121722; --ink:#e6e6e6; --muted:#a7b0c0; --accent:#4da3ff; --ok:#1ec971; --warn:#ffb703; --err:#ff5370; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:12px 16px;background:linear-gradient(90deg,#101626,#0b0e14)}
  header h1{margin:0;font-size:16px;font-weight:600}
  main{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px}
  @media (max-width:960px){main{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid #1a2333;border-radius:10px;box-shadow:0 0 0 1px #0d1320 inset}
  .pad{padding:12px}
  .controls label{display:block;margin:8px 0 4px;color:var(--muted)}
  .controls input[type=range]{width:100%}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{cursor:pointer;border:1px solid #1e2a3f;background:#0f1626;color:#eaeef7;padding:8px 10px;border-radius:8px}
  button.primary{background:var(--accent);color:#001020;border:none}
  button:disabled{opacity:.55;cursor:not-allowed}
  .toggle{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .toggle label{display:flex;align-items:center;gap:6px;background:#0e1524;border:1px solid #1b2440;padding:6px 8px;border-radius:8px}
  canvas{display:block;width:100%;height:auto;image-rendering:pixelated;border-radius:10px}
  .stat{display:grid;grid-template-columns:1fr auto;gap:6px 10px}
  .stat div{padding:4px 0;border-bottom:1px dashed #1f2b45}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #253557;background:#0e1524;color:var(--muted);font-size:12px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  footer{padding:10px 12px;color:#92a1bd}
  .log{max-height:180px;overflow:auto;background:#0c1220;border:1px solid #1a2336;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
</style>
</head>
<body>
<header>
  <h1>üêç Snake-ML ¬∑ Hybrid Max Mode (RL + BFS + Hamilton)</h1>
</header>

<main>
  <section class="panel pad">
    <div class="controls">
      <div class="row" style="margin-bottom:8px">
        <button id="btnStart" class="primary">Start</button>
        <button id="btnStop">Stop</button>
        <button id="btnReset">Reset</button>
        <span class="pill">Grid: <span id="gridLbl">15√ó15</span></span>
        <span class="pill">Speed: <span id="spdLbl">60 fps</span></span>
      </div>

      <label>Hastighet (frames/sek)</label>
      <input type="range" id="speed" min="5" max="120" step="1" value="60" />

      <label>Œµ (exploration) ‚Äì Max mode s√§tter detta till 0</label>
      <input type="range" id="eps" min="0" max="1" step="0.001" value="0" />

      <div class="toggle">
        <label><input type="checkbox" id="chkHybrid" checked /> Hybrid Controller</label>
        <label><input type="checkbox" id="chkBFS" checked /> BFS-r√§ddning</label>
        <label><input type="checkbox" id="chkHamilton" checked /> Hamilton i slutspel</label>
        <label><input type="checkbox" id="chkLogs" /> Logga h√§ndelser</label>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="btnMax" title="S√§tter Œµ=0, fryser agent och k√∂r hybrid">Max mode</button>
        <button id="btnRLonly" title="Inaktiverar BFS/Hamilton">RL only</button>
        <button id="btnSafe" title="BFS+Hamilton utan RL">Safe mode</button>
      </div>
    </div>

    <h3 style="margin-top:12px">Statistik</h3>
    <div class="stat mono" id="stats"></div>

    <h3 style="margin-top:12px">Logg</h3>
    <div class="log mono" id="log"></div>
  </section>

  <section class="panel pad">
    <canvas id="board" width="600" height="600"></canvas>
  </section>
</main>

<footer class="panel pad">
  Tips: K√∂r <b>Max mode</b> (Œµ=0) och l√•t RL ‚Üí BFS ‚Üí Hamilton ta dig ‚Äúhela v√§gen‚Äù.<br/>
  Vill du k√∂ra din tr√§nade agent? S√§tt <code>window.rlAgent = { chooseAction(state){ ‚Ä¶ } }</code> ‚Äì se markering i koden.
</footer>

<script>
///////////////////////////////////////////////
// Utils
///////////////////////////////////////////////
const DIRS = { UP:{x:0,y:-1}, DOWN:{x:0,y:1}, LEFT:{x:-1,y:0}, RIGHT:{x:1,y:0} };
const DIR_KEYS = ["UP","DOWN","LEFT","RIGHT"];
function samePos(a,b){ return a.x===b.x && a.y===b.y; }
function inside(x,y,cols,rows){ return x>=0 && y>=0 && x<cols && y<rows; }
function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

///////////////////////////////////////////////
// Snake Environment (single-file, no deps)
///////////////////////////////////////////////
class SnakeEnv{
  constructor(cols=15, rows=15){
    this.cols=cols|0; this.rows=rows|0;
    this.reset();
  }
  reset(){
    this.alive = true;
    this.deathReason = null;
    this.steps = 0;
    this.fruits = 0;
    this.totalReward = 0;
    this.stepsSinceFruit = 0;
    this.loopWindow = [];
    const cx = (this.cols/2|0), cy=(this.rows/2|0);
    this.dir = "RIGHT";
    this.snake = [{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
    this.placeFruit();
    return this.getState();
  }
  placeFruit(){
    const free=[];
    const occ = new Set(this.snake.map(p=>`${p.x},${p.y}`));
    for(let y=0;y<this.rows;y++){
      for(let x=0;x<this.cols;x++){
        const k=`${x},${y}`;
        if(!occ.has(k)) free.push({x,y});
      }
    }
    this.fruit = free.length? free[(Math.random()*free.length)|0] : {x:0,y:0};
  }
  opposite(a,b){
    return (a==="UP"&&b==="DOWN")||(a==="DOWN"&&b==="UP")||(a==="LEFT"&&b==="RIGHT")||(a==="RIGHT"&&b==="LEFT");
  }
  getState(){
    const head=this.snake[0];
    const dx = this.fruit.x-head.x;
    const dy = this.fruit.y-head.y;
    const nearWall = {
      up: head.y===0, down: head.y===this.rows-1,
      left: head.x===0, right: head.x===this.cols-1
    };
    return {
      cols:this.cols, rows:this.rows,
      head, fruit:this.fruit, dir:this.dir,
      snake:this.snake.slice(), // copy for safety
      len:this.snake.length,
      dx, dy, nearWall,
      steps:this.steps, fruits:this.fruits,
      stepsSinceFruit:this.stepsSinceFruit,
    };
  }
  step(action){
    if(!this.alive) return {done:true, reason:this.deathReason, reward:0, state:this.getState()};
    // Stoppa 180¬∞-v√§ndning
    if(this.opposite(this.dir, action)) action=this.dir;

    const dirVec = DIRS[action]||DIRS[this.dir];
    this.dir = action;
    const head = this.snake[0];
    const nx = head.x + dirVec.x;
    const ny = head.y + dirVec.y;

    // V√§ggkrasch?
    if(!inside(nx,ny,this.cols,this.rows)){
      this.alive=false; this.deathReason="WALL";
      return {done:true, reason:"WALL", reward:-5, state:this.getState()};
    }

    const nextIsFruit = (nx===this.fruit.x && ny===this.fruit.y);

    // Klassisk Snake-fix: r√§kna inte svansens sista ruta som kollision om den flyttas bort i detta steg
    const bodyToCheck = nextIsFruit ? this.snake : this.snake.slice(0,-1);
    const hitsBody = bodyToCheck.some(seg=>seg.x===nx && seg.y===ny);
    if(hitsBody){
      this.alive=false; this.deathReason="SELF";
      return {done:true, reason:"SELF", reward:-4, state:this.getState()};
    }

    // Flytta
    this.snake.unshift({x:nx,y:ny});
    let reward = -0.01; // liten stepp-kostnad
    if(nextIsFruit){
      this.fruits++;
      this.stepsSinceFruit=0;
      reward += 2.0;
      this.placeFruit();
    }else{
      this.snake.pop();
      this.stepsSinceFruit++;
    }

    this.steps++;
    this.totalReward += reward;

    // Loopdetektor (spara senaste 16 huvudpositioner)
    const key=`${nx},${ny}`;
    this.loopWindow.push(key);
    if(this.loopWindow.length>16) this.loopWindow.shift();

    return {done:false, reward, state:this.getState()};
  }
}

///////////////////////////////////////////////
// BFS (kortaste v√§g till frukt)
///////////////////////////////////////////////
function bfsPath(env){
  const {cols,rows,snake,fruit} = env.getState();
  const head = snake[0];
  // Blockera kroppen, men till√•t att g√• in i svansens *sista* cell (den r√∂r sig bort om vi inte √§ter)
  const bodySet = new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
  const q=[head];
  const prev = new Map();
  const seen = new Set([`${head.x},${head.y}`]);

  while(q.length){
    const cur=q.shift();
    if(cur.x===fruit.x && cur.y===fruit.y){
      // Rekonstruera stig
      const path=[cur];
      let k=`${cur.x},${cur.y}`;
      while(prev.has(k)){ const p=prev.get(k); path.push(p); k=`${p.x},${p.y}`; }
      path.reverse();
      return path;
    }
    for(const d of DIR_KEYS){
      const v=DIRS[d];
      const nx=cur.x+v.x, ny=cur.y+v.y;
      if(!inside(nx,ny,cols,rows)) continue;
      const nk=`${nx},${ny}`;
      if(seen.has(nk)) continue;
      if(bodySet.has(nk)) continue;
      seen.add(nk);
      prev.set(nk,cur);
      q.push({x:nx,y:ny});
    }
  }
  return null; // ingen v√§g
}

///////////////////////////////////////////////
// Hamilton: serpentin-g√•ng + ‚Äúpath order‚Äù strategi
// Obs: riktig Hamilton-CYKEL kr√§ver j√§mn dimension. F√∂r 15√ó15 k√∂r vi path+wrap-logik med fallback BFS.
///////////////////////////////////////////////
function generateSerpentineOrder(cols,rows){
  // Returnerar en lista av celler i ‚Äúlawnmower‚Äù-ordning
  const order=[];
  for(let y=0;y<rows;y++){
    if(y%2===0){
      for(let x=0;x<cols;x++) order.push({x,y});
    }else{
      for(let x=cols-1;x>=0;x--) order.push({x,y});
    }
  }
  // Map fr√•n ‚Äúx,y‚Äù -> index
  const idx=new Map(order.map((p,i)=>[`${p.x},${p.y}`,i]));
  return {order, idx};
}
function nextOnSerpentine(env, serp){
  const {head} = env.getState();
  const k=`${head.x},${head.y}`;
  const i = serp.idx.get(k);
  if(i===undefined) return null;
  const next = serp.order[(i+1) % serp.order.length];
  return next;
}
function dirToAction(from,to){
  if(!to||!from) return "RIGHT";
  if(to.x>from.x) return "RIGHT";
  if(to.x<from.x) return "LEFT";
  if(to.y>from.y) return "DOWN";
  return "UP";
}

///////////////////////////////////////////////
//
// RL-agent (stub) ‚Äî BYT till din tr√§nade agent h√§r:
// S√§tt window.rlAgent = { chooseAction(state){ ... } } f√∂re start.
//
///////////////////////////////////////////////
if(typeof window.rlAgent!=="object"){
  window.rlAgent = {
    // Enkel heuristik: g√• mot frukten, f√∂rs√∂k undvika v√§ggar/180¬∞, fallback till s√§kra moves
    chooseAction(state){
      const {head,fruit,cols,rows,dir} = state;
      const prefs=[];
      if(fruit.x>head.x) prefs.push("RIGHT");
      if(fruit.x<head.x) prefs.push("LEFT");
      if(fruit.y>head.y) prefs.push("DOWN");
      if(fruit.y<head.y) prefs.push("UP");
      // fyll p√• med andra riktningar som backup
      for(const d of DIR_KEYS) if(!prefs.includes(d)) prefs.push(d);

      // undvik 180¬∞
      const opposite = {UP:"DOWN",DOWN:"UP",LEFT:"RIGHT",RIGHT:"LEFT"}[dir];
      const snakeSet = new Set(state.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
      for(const a of prefs){
        if(a===opposite) continue;
        const v=DIRS[a];
        const nx=head.x+v.x, ny=head.y+v.y;
        if(!inside(nx,ny,cols,rows)) continue;
        if(snakeSet.has(`${nx},${ny}`)) continue;
        return a;
      }
      return dir; // sista utv√§g
    }
  };
}

///////////////////////////////////////////////
// Hybrid Controller
///////////////////////////////////////////////
class HybridController{
  constructor(env, opts={}){
    this.env = env;
    this.epsilon = 0; // s√§tts via UI
    this.enableHybrid = true;
    this.enableBFS = true;
    this.enableHamilton = true;
    this.bfsStuckSteps = opts.bfsStuckSteps ?? 80;
    this.loopRepeatThreshold = opts.loopRepeatThreshold ?? 3;
    this.hamiltonFillRatio = opts.hamiltonFillRatio ?? 0.80;
    this.mode = "hybrid"; // "hybrid" | "rl" | "safe"
    this._serp = generateSerpentineOrder(env.cols, env.rows);
  }
  setMode(m){
    this.mode=m;
  }
  setFlags({hybrid,bfs,hamilton}){
    if(hybrid!==undefined) this.enableHybrid=!!hybrid;
    if(bfs!==undefined) this.enableBFS=!!bfs;
    if(hamilton!==undefined) this.enableHamilton=!!hamilton;
  }
  setEpsilon(e){ this.epsilon=Math.max(0,Math.min(1, +e || 0)); }
  _log(msg){ if(ui.chkLogs.checked) appendLog(msg); }

  chooseAction(){
    const s = this.env.getState();

    // Safe mode: ignorera RL helt, anv√§nd BFS/Hamilton
    if(this.mode==="safe"){
      const a = this._hamiltonOrBFS(s);
      if(a) return a;
      return this._fallbackRL(s);
    }

    // RL only: ren agent (men respektera epsilon)
    if(this.mode==="rl"){
      return this._rlEpsGreedy(s);
    }

    // Hybrid:
    // 1) Hamilton i slutspel
    const fill = s.len/(s.cols*s.rows);
    if(this.enableHamilton && fill >= this.hamiltonFillRatio){
      const a = this._hamiltonStep(s);
      if(a){ this._log(`Hamilton step (fill ${(fill*100).toFixed(1)}%)`); return a; }
    }

    // 2) BFS vid fastna/loop
    const loops = this._estimateLoopCount();
    if(this.enableBFS && (s.stepsSinceFruit >= this.bfsStuckSteps || loops>=this.loopRepeatThreshold)){
      const a = this._bfsStep(s);
      if(a){ this._log(`BFS rescue (sinceFruit=${s.stepsSinceFruit}, loops=${loops})`); return a; }
    }

    // 3) RL standard
    return this._rlEpsGreedy(s);
  }

  _rlEpsGreedy(s){
    if(Math.random() < this.epsilon){
      // slumpat lagligt drag
      const legal=[];
      for(const a of DIR_KEYS){
        if(this.env.opposite(s.dir,a)) continue;
        const v=DIRS[a], nx=s.head.x+v.x, ny=s.head.y+v.y;
        if(!inside(nx,ny,s.cols,s.rows)) continue;
        const bodySet=new Set(s.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
        if(bodySet.has(`${nx},${ny}`)) continue;
        legal.push(a);
      }
      if(legal.length) return legal[(Math.random()*legal.length)|0];
    }
    return window.rlAgent.chooseAction(s);
  }

  _bfsStep(s){
    const path = bfsPath(this.env);
    if(path && path.length>1){
      const next = path[1];
      return dirToAction(s.head,next);
    }
    return null;
  }

  _hamiltonStep(s){
    if(!this._serp) this._serp = generateSerpentineOrder(s.cols,s.rows);
    const next = nextOnSerpentine(this.env, this._serp);
    if(!next) return null;

    // Om n√§sta serpentin-cell √§r upptagen av kroppen (f√∂rutom svansens sista),
    // prova BFS som ‚Äútail-chase‚Äù fallback ‚Äì annars k√∂r RL.
    const bodySet=new Set(s.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
    if(bodySet.has(`${next.x},${next.y}`)){
      const path=bfsPath(this.env);
      if(path && path.length>1) return dirToAction(s.head, path[1]);
      return null;
    }
    return dirToAction(s.head,next);
  }

  _hamiltonOrBFS(s){
    const aH = this._hamiltonStep(s);
    if(aH) return aH;
    const aB = this._bfsStep(s);
    if(aB) return aB;
    return null;
  }

  _fallbackRL(s){ return window.rlAgent.chooseAction(s); }

  _estimateLoopCount(){
    // grov loopindikator: antal duplicerade huvudpositioner i f√∂nster
    const arr = this.env.loopWindow;
    if(arr.length<8) return 0;
    const seen=new Map();
    for(const k of arr) seen.set(k,(seen.get(k)||0)+1);
    let repeats=0;
    for(const v of seen.values()) if(v>1) repeats++;
    return repeats; // 0..n
  }
}

///////////////////////////////////////////////
// Rendering
///////////////////////////////////////////////
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function draw(env){
  const {cols,rows,snake,fruit} = env.getState();
  const cw = canvas.width, ch=canvas.height;
  const cs = Math.floor(Math.min(cw/cols, ch/rows));

  // bakgrund
  ctx.fillStyle = "#0b0e14";
  ctx.fillRect(0,0,cw,ch);

  // grid-rutor
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const px=x*cs, py=y*cs;
      ctx.fillStyle = (x+y)%2===0 ? "#111827" : "#0f172a";
      ctx.fillRect(px,py,cs,cs);
    }
  }

  // frukt
  ctx.fillStyle = "#ff5370";
  ctx.fillRect(fruit.x*cs+1, fruit.y*cs+1, cs-2, cs-2);

  // snake
  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    const px=s.x*cs, py=s.y*cs;
    ctx.fillStyle = i===0 ? "#4da3ff" : "#1ec971";
    ctx.fillRect(px+1,py+1,cs-2,cs-2);
  }
}

///////////////////////////////////////////////
// UI + loop
///////////////////////////////////////////////
const ui = {
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnReset: document.getElementById('btnReset'),
  btnMax: document.getElementById('btnMax'),
  btnRLonly: document.getElementById('btnRLonly'),
  btnSafe: document.getElementById('btnSafe'),
  speed: document.getElementById('speed'),
  eps: document.getElementById('eps'),
  chkHybrid: document.getElementById('chkHybrid'),
  chkBFS: document.getElementById('chkBFS'),
  chkHamilton: document.getElementById('chkHamilton'),
  chkLogs: document.getElementById('chkLogs'),
  stats: document.getElementById('stats'),
  log: document.getElementById('log'),
  spdLbl: document.getElementById('spdLbl'),
  gridLbl: document.getElementById('gridLbl')
};
function appendLog(msg){
  const t = new Date().toLocaleTimeString();
  ui.log.textContent += `[${t}] ${msg}\n`;
  ui.log.scrollTop = ui.log.scrollHeight;
}
function setStats(){
  const s = env.getState();
  const fill = (s.len/(s.cols*s.rows))*100;
  ui.stats.innerHTML = `
    <div>Steg</div><div>${s.steps}</div>
    <div>Frukt</div><div>${s.fruits}</div>
    <div>L√§ngd</div><div>${s.len}</div>
    <div>Steps sedan frukt</div><div>${s.stepsSinceFruit}</div>
    <div>Fyllnadsgrad</div><div>${fill.toFixed(1)}%</div>
  `;
}

let env = new SnakeEnv(15,15);
let ctrl = new HybridController(env, { bfsStuckSteps:80, loopRepeatThreshold:3, hamiltonFillRatio:0.80 });
ui.gridLbl.textContent = `${env.cols}√ó${env.rows}`;

let running=false, rafId=null, acc=0, fps=+ui.speed.value;
ui.spdLbl.textContent = `${fps} fps`;

function tick(dt){
  if(!running) return;
  acc += dt;
  const frameTime = 1000/fps;
  while(acc>=frameTime){
    acc -= frameTime;
    stepOnce();
  }
  draw(env);
  setStats();
  rafId = requestAnimationFrame(loop);
}
function loop(ts){
  if(!loop.last) loop.last = ts;
  const dt = ts - loop.last; loop.last = ts;
  tick(dt);
}
function stepOnce(){
  if(!env.alive){
    // auto-reset n√§sta episod
    const reason=env.deathReason;
    if(reason) appendLog(`üí• Krasch: ${reason}`);
    env.reset();
    return;
  }
  const action = ctrl.enableHybrid ? ctrl.chooseAction() : window.rlAgent.chooseAction(env.getState());
  const res = env.step(action);
  if(res.done){
    appendLog(`üí• Episode slut: ${res.reason||"d√∂d"}`);
  }
}

///////////////////////////////////////////////
// Event handlers
///////////////////////////////////////////////
ui.btnStart.onclick=()=>{
  if(running) return;
  running=true; loop.last=undefined;
  appendLog('‚ñ∂Ô∏è Start');
  rafId=requestAnimationFrame(loop);
};
ui.btnStop.onclick=()=>{
  running=false; if(rafId) cancelAnimationFrame(rafId);
  appendLog('‚è∏Ô∏è Stop');
};
ui.btnReset.onclick=()=>{
  env.reset(); draw(env); setStats(); appendLog('üîÑ Reset');
};

ui.speed.oninput=()=>{
  fps=+ui.speed.value||60;
  ui.spdLbl.textContent=`${fps} fps`;
};
ui.eps.oninput=()=>{
  ctrl.setEpsilon(+ui.eps.value||0);
};

ui.chkHybrid.onchange=()=>{ ctrl.enableHybrid=ui.chkHybrid.checked; };
ui.chkBFS.onchange=()=>{ ctrl.enableBFS=ui.chkBFS.checked; };
ui.chkHamilton.onchange=()=>{ ctrl.enableHamilton=ui.chkHamilton.checked; };

ui.btnMax.onclick=()=>{
  ui.eps.value = "0";
  ctrl.setEpsilon(0);
  ctrl.setFlags({hybrid:true,bfs:true,hamilton:true});
  ctrl.setMode("hybrid");
  ui.chkHybrid.checked=true; ui.chkBFS.checked=true; ui.chkHamilton.checked=true;
  appendLog('üèÅ Max mode: Œµ=0, Hybrid+BFS+Hamilton aktiva');
};
ui.btnRLonly.onclick=()=>{
  ctrl.setMode("rl");
  ctrl.setFlags({hybrid:false}); // praktiskt: kryssruta p√•verkar inte "mode", men vi visar √§nd√•
  ui.chkHybrid.checked=false;
  appendLog('ü§ñ RL only (inga BFS/Hamilton-ingrepp)');
};
ui.btnSafe.onclick=()=>{
  ctrl.setMode("safe");
  ctrl.setFlags({hybrid:true,bfs:true,hamilton:true});
  ui.chkHybrid.checked=true; ui.chkBFS.checked=true; ui.chkHamilton.checked=true;
  ui.eps.value="0"; ctrl.setEpsilon(0);
  appendLog('üõü Safe mode: BFS+Hamilton, ingen RL (Œµ=0)');
};

// Startl√§ge: rita stillbild
draw(env); setStats();
</script>
</body>
</html>
