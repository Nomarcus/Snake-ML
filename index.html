<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake NEAT Lab</title>
  <style>
    :root {
      --bg: #090d1f;
      --panel: #141936;
      --ink: #eef2ff;
      --muted: #9ba8d6;
      --accent-a: #8b5cf6;
      --accent-b: #ec4899;
      --danger: #f43f5e;
      --success: #34d399;
      --stroke: rgba(134, 144, 214, 0.18);
      --shadow: 0 24px 50px rgba(6, 8, 24, 0.55);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(160% 140% at 20% -20%, #202866 0%, #131834 45%, #090d1f 100%);
      color: var(--ink);
      font: 14px/1.5 "Inter", "Segoe UI", Roboto, sans-serif;
    }

    header {
      padding: 20px 0;
      position: sticky;
      top: 0;
      z-index: 10;
      background: linear-gradient(135deg, rgba(28, 33, 72, 0.9), rgba(12, 16, 36, 0.92));
      backdrop-filter: blur(18px);
      border-bottom: 1px solid var(--stroke);
      box-shadow: 0 20px 40px rgba(6, 8, 20, 0.6);
    }

    header .header-inner {
      margin: 0 auto;
      padding: 0 32px;
      display: flex;
      align-items: center;
      gap: 18px;
      max-width: 1280px;
    }

    .logo {
      font-weight: 800;
      font-size: 20px;
      display: flex;
      align-items: center;
      gap: 12px;
      color: var(--ink);
      letter-spacing: 0.01em;
    }

    .logo::before {
      content: "";
      width: 24px;
      height: 24px;
      border-radius: 8px;
      background: linear-gradient(140deg, var(--accent-a), var(--accent-b));
      box-shadow: 0 0 24px rgba(236, 72, 153, 0.4);
    }

    .logo-text {
      background: linear-gradient(140deg, var(--accent-a), var(--accent-b));
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .status-group {
      margin-left: auto;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .badge {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid rgba(134, 144, 214, 0.35);
      background: rgba(26, 32, 74, 0.75);
      color: #cfd5ff;
      font-size: 12px;
      font-weight: 600;
      box-shadow: 0 8px 18px rgba(8, 12, 32, 0.35);
    }

    .badge.soft {
      background: rgba(139, 92, 246, 0.22);
      border-color: rgba(139, 92, 246, 0.55);
      color: #f5f4ff;
    }

    .badge.success {
      background: rgba(52, 211, 153, 0.18);
      border-color: rgba(52, 211, 153, 0.55);
      color: #dcfce7;
    }

    main.layout {
      margin: 32px auto 48px;
      padding: 0 24px 40px;
      display: grid;
      gap: 32px;
      max-width: 1280px;
      grid-template-columns: minmax(0, 2.4fr) minmax(0, 1fr);
      align-items: start;
    }

    .card {
      background: linear-gradient(155deg, rgba(34, 41, 82, 0.88) 0%, rgba(18, 21, 46, 0.92) 100%);
      border: 1px solid var(--stroke);
      border-radius: 24px;
      padding: 24px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 18px;
      backdrop-filter: blur(18px);
    }

    .card-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    h1 {
      margin: 0;
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 0.01em;
    }

    h2 {
      margin: 0;
      font-size: 20px;
      color: #f0f2ff;
      letter-spacing: 0.01em;
    }

    h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    p {
      margin: 0;
      color: var(--muted);
    }

    canvas#board {
      width: 100%;
      max-width: 560px;
      aspect-ratio: 1 / 1;
      border-radius: 26px;
      background: radial-gradient(140% 140% at 30% 20%, #273067 0%, #151a3a 50%, #0d1127 100%);
      border: 1px solid rgba(128, 140, 210, 0.25);
      box-shadow: 0 40px 80px rgba(8, 12, 42, 0.55);
      align-self: center;
    }

    .stats-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    }

    .stat {
      display: flex;
      flex-direction: column;
      gap: 4px;
      padding: 12px 14px;
      border-radius: 18px;
      border: 1px solid rgba(149, 158, 214, 0.2);
      background: rgba(16, 21, 44, 0.7);
    }

    .stat span {
      color: var(--muted);
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .stat strong {
      font-size: 18px;
      font-weight: 700;
    }

    .control-section {
      display: flex;
      flex-direction: column;
      gap: 14px;
      padding: 18px 20px;
      border-radius: 18px;
      border: 1px solid rgba(149, 158, 214, 0.18);
      background: rgba(13, 17, 38, 0.6);
    }

    .control-section h3 {
      font-size: 15px;
      color: #f4f5ff;
    }

    .buttons-row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    button {
      appearance: none;
      border: 1px solid rgba(134, 144, 214, 0.35);
      border-radius: 12px;
      background: rgba(33, 38, 80, 0.88);
      color: var(--ink);
      padding: 10px 16px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.15s ease, background 0.2s ease, border-color 0.2s ease;
      font-size: 13px;
      letter-spacing: 0.01em;
    }

    button.primary {
      background: linear-gradient(140deg, var(--accent-a), var(--accent-b));
      border: none;
      color: #fff;
    }

    button:disabled {
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
    }

    button:not(:disabled):hover {
      transform: translateY(-1px);
      border-color: rgba(139, 92, 246, 0.75);
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    label span.hint {
      color: var(--muted);
      font-size: 12px;
    }

    input[type="number"],
    input[type="range"] {
      width: 100%;
    }

    input[type="number"] {
      background: rgba(14, 18, 34, 0.7);
      border: 1px solid rgba(134, 144, 214, 0.35);
      border-radius: 10px;
      padding: 8px 10px;
      color: var(--ink);
    }

    input[type="range"] {
      accent-color: var(--accent-a);
    }

    .mono {
      font-family: "JetBrains Mono", "Fira Code", monospace;
      font-size: 12px;
      color: #cfd5ff;
    }

    .log {
      max-height: 160px;
      overflow-y: auto;
      padding: 12px 16px;
      border-radius: 18px;
      border: 1px solid rgba(149, 158, 214, 0.2);
      background: rgba(12, 16, 34, 0.6);
      font-family: "JetBrains Mono", monospace;
      font-size: 12px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .log-entry {
      color: #dde1ff;
      opacity: 0.85;
    }

    .log-entry strong {
      color: #fff;
    }

    ul.species-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 220px;
      overflow-y: auto;
    }

    ul.species-list li {
      display: flex;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(134, 144, 214, 0.25);
      background: rgba(17, 20, 42, 0.55);
      font-size: 12px;
    }

    @media (max-width: 1024px) {
      main.layout {
        grid-template-columns: 1fr;
      }

      canvas#board {
        max-width: none;
      }
    }
  </style>
</head>
<body>
  <header>
    <div class="header-inner">
      <div class="logo">
        <span class="logo-text">Snake NEAT Lab</span>
      </div>
      <div class="status-group">
        <span class="badge" id="statusBadge">Status: idle</span>
        <span class="badge soft" id="generationBadge">Generation 0</span>
        <span class="badge soft" id="speciesBadge">Arter 0</span>
      </div>
    </div>
  </header>
  <main class="layout">
    <section class="card game-card">
      <div class="card-head">
        <div>
          <h2>Träningsvy</h2>
          <p>Visualiserar bästa genomet med NEAT-baserad inlärning.</p>
        </div>
        <button id="watchBtn" class="primary">Titta på bästa</button>
      </div>
      <canvas id="board" width="520" height="520"></canvas>
      <div class="stats-grid">
        <div class="stat">
          <span>Generation</span>
          <strong id="statGeneration">0</strong>
        </div>
        <div class="stat">
          <span>Bästa fitness</span>
          <strong id="statBestFitness">0</strong>
        </div>
        <div class="stat">
          <span>Medel fitness</span>
          <strong id="statAvgFitness">0</strong>
        </div>
        <div class="stat">
          <span>Föregående förbättring</span>
          <strong id="statImproved">–</strong>
        </div>
        <div class="stat">
          <span>Genomsnitt frukter</span>
          <strong id="statFruit">0</strong>
        </div>
        <div class="stat">
          <span>Genomsnitt steg</span>
          <strong id="statSteps">0</strong>
        </div>
      </div>
      <div class="log" id="eventLog" aria-live="polite"></div>
    </section>
    <section class="card control-card">
      <div class="card-head">
        <h2>Kontrollpanel</h2>
      </div>
      <div class="control-section">
        <h3>Träningskontroller</h3>
        <div class="buttons-row">
          <button id="startBtn" class="primary">Starta träning</button>
          <button id="pauseBtn" disabled>Pausa</button>
          <button id="stepBtn">Stega generation</button>
        </div>
        <div class="field">
          <label>
            Brädstorlek
            <span class="hint">Ändra storleken på spelplanen (10–24).</span>
            <input type="range" id="gridSize" min="10" max="24" value="14" />
            <span class="mono" id="gridReadout">14×14</span>
          </label>
        </div>
        <div class="field">
          <label>
            Maxsteg per episod
            <input type="number" id="maxSteps" min="100" max="5000" step="50" value="600" />
          </label>
        </div>
        <div class="field">
          <label>
            Episoder per utvärdering
            <input type="number" id="episodeCount" min="1" max="10" value="3" />
          </label>
        </div>
      </div>
      <div class="control-section">
        <h3>NEAT-parametrar</h3>
        <div class="field">
          <label>
            Populationsstorlek
            <input type="number" id="populationSize" min="10" max="200" value="60" />
          </label>
        </div>
        <div class="field">
          <label>
            Elit-andel
            <span class="hint">Andel individer som kopieras direkt till nästa generation.</span>
            <input type="number" id="eliteFraction" min="0" max="0.6" step="0.05" value="0.15" />
          </label>
        </div>
        <div class="field">
          <label>
            Kompatibilitetströskel
            <input type="number" id="compatThreshold" min="0.1" max="6" step="0.1" value="3.0" />
          </label>
        </div>
        <div class="field">
          <label>
            Viktförändring (σ)
            <input type="number" id="weightSigma" min="0.05" max="2" step="0.05" value="0.5" />
          </label>
        </div>
        <div class="field">
          <label>
            Sannolikhet viktmutering
            <input type="number" id="weightProb" min="0" max="1" step="0.05" value="0.8" />
          </label>
        </div>
        <div class="field">
          <label>
            Lägg till koppling
            <input type="number" id="linkProb" min="0" max="1" step="0.05" value="0.3" />
          </label>
        </div>
        <div class="field">
          <label>
            Lägg till nod
            <input type="number" id="nodeProb" min="0" max="1" step="0.05" value="0.2" />
          </label>
        </div>
        <div class="field">
          <label>
            Av/på-koppling
            <input type="number" id="toggleProb" min="0" max="1" step="0.05" value="0.05" />
          </label>
        </div>
      </div>
      <div class="control-section">
        <h3>Artöversikt</h3>
        <ul class="species-list" id="speciesList"></ul>
      </div>
    </section>
  </main>
  <script type="module">
    import { bfsPath as computeBfsPath, bfsDistance as computeBfsDistance } from './src/path_helpers.js';
    const rand = {
      float(min = 0, max = 1) {
        return Math.random() * (max - min) + min;
      },
      choice(arr) {
        if (!Array.isArray(arr) || !arr.length) return undefined;
        return arr[(Math.random() * arr.length) | 0];
      },
      gaussian(mu = 0, sigma = 1) {
        let u = 0;
        let v = 0;
        while (u === 0) u = Math.random();
        while (v === 0) v = Math.random();
        return Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v) * sigma + mu;
      }
    };

    const DEFAULT_REWARD_CONFIG = {
      stepPenalty: 0.015,
      wallPenalty: 2.5,
      selfPenalty: 2.2,
      timeoutPenalty: 1.5,
      fruitReward: 4,
      victoryReward: 25,
      approachBonus: 0.1,
      retreatPenalty: 0.14,
      idlePenalty: 0.02,
      helperWeight: 0.35,
      helperPenalty: 0.5,
      loopPenalty: 0.45,
      revisitPenalty: 0.08,
      revisitIncrement: 0.25,
      visitDecay: 0.992,
      spaceGainReward: 1.2,
      spaceLossPenalty: 2.4,
      tailChaseBonus: 0.25,
      tailPressureThreshold: 0.18,
      fruitPathBonus: 0.35,
      tailPathBonus: 0.45,
      pathRecoveryBonus: 0.8,
      pathLossPenalty: 0.22,
      noFruitPathPenalty: 1.2,
      noTailPathPenalty: 2.1,
      trapThreshold: 0.16,
      trapPenalty: 2.5,
      trapCounterLimit: 10,
      coverageAdvanceReward: 0.28,
      coverageDeviationPenalty: 0.24,
      coverageStartThreshold: 0.55
    };

    const LOOP_HISTORY_LIMIT = 16;

    class NodeGene {
      constructor(id, type, layer, options = {}) {
        this.id = id;
        this.type = type;
        this.layer = layer;
        this.outputIndex = options.outputIndex ?? null;
      }

      clone() {
        return new NodeGene(this.id, this.type, this.layer, { outputIndex: this.outputIndex });
      }
    }

    class ConnectionGene {
      constructor(inNode, outNode, weight, innovation, enabled = true) {
        this.inNode = inNode;
        this.outNode = outNode;
        this.weight = weight;
        this.innovation = innovation;
        this.enabled = enabled;
      }

      clone() {
        return new ConnectionGene(this.inNode, this.outNode, this.weight, this.innovation, this.enabled);
      }
    }

    class InnovationTracker {
      constructor(startNodeId = 0) {
        this.nextInnovation = 1;
        this.connectionMap = new Map();
        this.nextNodeId = startNodeId;
      }

      getInnovation(inNode, outNode) {
        const key = `${inNode}:${outNode}`;
        if (!this.connectionMap.has(key)) {
          this.connectionMap.set(key, this.nextInnovation++);
        }
        return this.connectionMap.get(key);
      }

      getNextNodeId() {
        const id = this.nextNodeId;
        this.nextNodeId += 1;
        return id;
      }
    }

    class Genome {
      constructor(config) {
        this.config = config;
        this.nodes = new Map();
        this.connections = new Map();
        this.inputIds = [];
        this.outputIds = [];
        this.biasId = null;
        this.cachedOrder = null;
        this.cachedIncoming = null;
        this.fitness = 0;
        this.stats = { reward: 0, fruits: 0, steps: 0 };
      }

      static createInitial(config, tracker) {
        const genome = new Genome(config);
        for (let i = 0; i < config.inputCount; i += 1) {
          genome.addNodeGene(new NodeGene(i, 'input', 0));
        }
        const biasId = config.inputCount;
        genome.addNodeGene(new NodeGene(biasId, 'bias', 0));
        genome.biasId = biasId;
        for (let i = 0; i < config.outputCount; i += 1) {
          const nodeId = config.inputCount + 1 + i;
          genome.addNodeGene(new NodeGene(nodeId, 'output', 1, { outputIndex: i }));
        }
        tracker.nextNodeId = Math.max(tracker.nextNodeId, config.inputCount + config.outputCount + 1);
        const sources = [...genome.inputIds];
        if (genome.biasId !== null) sources.push(genome.biasId);
        for (const outId of genome.outputIds) {
          for (const src of sources) {
            const innovation = tracker.getInnovation(src, outId);
            const conn = new ConnectionGene(src, outId, rand.float(-1, 1), innovation, true);
            genome.addConnectionGene(conn);
          }
        }
        return genome;
      }

      clone() {
        const copy = new Genome(this.config);
        copy.nodes = new Map();
        this.nodes.forEach((node) => {
          copy.nodes.set(node.id, node.clone());
        });
        copy.connections = new Map();
        this.connections.forEach((conn, key) => {
          copy.connections.set(key, conn.clone());
        });
        copy.inputIds = [...this.inputIds];
        copy.outputIds = [...this.outputIds];
        copy.biasId = this.biasId;
        copy.invalidateCaches();
        copy.fitness = this.fitness;
        copy.stats = { ...this.stats };
        return copy;
      }

      invalidateCaches() {
        this.cachedOrder = null;
        this.cachedIncoming = null;
      }

      addNodeGene(node) {
        this.nodes.set(node.id, node);
        if (node.type === 'input') {
          if (!this.inputIds.includes(node.id)) {
            this.inputIds.push(node.id);
            this.inputIds.sort((a, b) => a - b);
          }
        } else if (node.type === 'output') {
          if (!this.outputIds.includes(node.id)) {
            this.outputIds.push(node.id);
            this.outputIds.sort((a, b) => {
              const na = this.nodes.get(a);
              const nb = this.nodes.get(b);
              const ia = na?.outputIndex ?? 0;
              const ib = nb?.outputIndex ?? 0;
              return ia === ib ? a - b : ia - ib;
            });
          }
        } else if (node.type === 'bias') {
          this.biasId = node.id;
        }
        this.invalidateCaches();
      }

      addConnectionGene(conn) {
        this.connections.set(conn.innovation, conn);
        this.invalidateCaches();
      }

      hasConnection(inId, outId) {
        for (const conn of this.connections.values()) {
          if (conn.inNode === inId && conn.outNode === outId) return true;
        }
        return false;
      }

      getNodeOrder() {
        if (!this.cachedOrder) {
          this.cachedOrder = Array.from(this.nodes.values()).sort((a, b) => {
            if (a.layer === b.layer) return a.id - b.id;
            return a.layer - b.layer;
          });
        }
        return this.cachedOrder;
      }

      getIncomingMap() {
        if (!this.cachedIncoming) {
          const incoming = new Map();
          this.connections.forEach((conn) => {
            if (!incoming.has(conn.outNode)) incoming.set(conn.outNode, []);
            incoming.get(conn.outNode).push(conn);
          });
          this.cachedIncoming = incoming;
        }
        return this.cachedIncoming;
      }

      activate(inputs) {
        const order = this.getNodeOrder();
        const incoming = this.getIncomingMap();
        const values = new Map();
        let inputIdx = 0;
        for (const node of order) {
          if (node.type === 'input') {
            const value = Array.isArray(inputs) || ArrayBuffer.isView(inputs)
              ? inputs[inputIdx] ?? 0
              : 0;
            values.set(node.id, value);
            inputIdx += 1;
          } else if (node.type === 'bias') {
            values.set(node.id, 1);
          } else {
            const inc = incoming.get(node.id) || [];
            let sum = 0;
            for (const conn of inc) {
              if (!conn.enabled) continue;
              const prev = values.get(conn.inNode);
              if (prev !== undefined) sum += prev * conn.weight;
            }
            const activated = Math.tanh(sum);
            values.set(node.id, activated);
          }
        }
        return this.outputIds.map((id) => values.get(id) ?? 0);
      }

      decideAction(state) {
        const outputs = this.activate(state);
        let bestIndex = 0;
        let bestValue = -Infinity;
        outputs.forEach((val, idx) => {
          if (val > bestValue) {
            bestValue = val;
            bestIndex = idx;
          }
        });
        return { action: bestIndex, outputs };
      }

      mutateWeights(config) {
        const resetProb = config.resetProb ?? 0.1;
        this.connections.forEach((conn) => {
          if (Math.random() < (config.weightProb ?? 0.8)) {
            if (Math.random() < resetProb) {
              conn.weight = rand.float(-2, 2);
            } else {
              conn.weight += rand.gaussian(0, config.sigma ?? 0.5);
            }
          }
        });
      }

      mutateAddConnection(tracker) {
        const nodes = Array.from(this.nodes.values());
        const sources = nodes.filter((n) => n.type !== 'output');
        const targets = nodes.filter((n) => n.type !== 'input' && n.type !== 'bias');
        for (let attempt = 0; attempt < 25; attempt += 1) {
          const from = rand.choice(sources);
          if (!from) continue;
          const candidates = targets.filter((node) => node.layer > from.layer && !this.hasConnection(from.id, node.id));
          if (!candidates.length) continue;
          const to = rand.choice(candidates);
          const innovation = tracker.getInnovation(from.id, to.id);
          const conn = new ConnectionGene(from.id, to.id, rand.float(-1, 1), innovation, true);
          this.addConnectionGene(conn);
          return true;
        }
        return false;
      }

      mutateAddNode(tracker) {
        const enabledConnections = Array.from(this.connections.values()).filter((c) => c.enabled);
        if (!enabledConnections.length) return false;
        const conn = rand.choice(enabledConnections);
        conn.enabled = false;
        const newNodeId = tracker.getNextNodeId();
        const fromNode = this.nodes.get(conn.inNode);
        const toNode = this.nodes.get(conn.outNode);
        const newLayer = (fromNode.layer + toNode.layer) / 2;
        const newNode = new NodeGene(newNodeId, 'hidden', newLayer);
        this.addNodeGene(newNode);
        const inInnovation = tracker.getInnovation(fromNode.id, newNodeId);
        const outInnovation = tracker.getInnovation(newNodeId, toNode.id);
        this.addConnectionGene(new ConnectionGene(fromNode.id, newNodeId, 1, inInnovation, true));
        this.addConnectionGene(new ConnectionGene(newNodeId, toNode.id, conn.weight, outInnovation, true));
        return true;
      }

      mutateToggleConnection() {
        const connections = Array.from(this.connections.values());
        if (!connections.length) return false;
        const conn = rand.choice(connections);
        conn.enabled = !conn.enabled;
        return true;
      }

      mutate(config, tracker) {
        this.mutateWeights(config);
        if (Math.random() < (config.addConnectionProb ?? 0.3)) {
          this.mutateAddConnection(tracker);
        }
        if (Math.random() < (config.addNodeProb ?? 0.2)) {
          this.mutateAddNode(tracker);
        }
        if (Math.random() < (config.toggleConnectionProb ?? 0.05)) {
          this.mutateToggleConnection();
        }
      }

      compatibilityDistance(other, config) {
        const genesA = Array.from(this.connections.values()).sort((a, b) => a.innovation - b.innovation);
        const genesB = Array.from(other.connections.values()).sort((a, b) => a.innovation - b.innovation);
        let i = 0;
        let j = 0;
        let matching = 0;
        let weightDiff = 0;
        let disjoint = 0;
        while (i < genesA.length && j < genesB.length) {
          const geneA = genesA[i];
          const geneB = genesB[j];
          if (geneA.innovation === geneB.innovation) {
            matching += 1;
            weightDiff += Math.abs(geneA.weight - geneB.weight);
            i += 1;
            j += 1;
          } else if (geneA.innovation < geneB.innovation) {
            disjoint += 1;
            i += 1;
          } else {
            disjoint += 1;
            j += 1;
          }
        }
        const excess = (genesA.length - i) + (genesB.length - j);
        const N = Math.max(genesA.length, genesB.length, 1);
        const avgWeight = matching ? weightDiff / matching : 0;
        const c1 = config.c1 ?? 1;
        const c2 = config.c2 ?? 1;
        const c3 = config.c3 ?? 0.4;
        return (c1 * excess) / N + (c2 * disjoint) / N + c3 * avgWeight;
      }

      static crossover(parentA, parentB, tracker) {
        const bestParent = parentA.fitness >= parentB.fitness ? parentA : parentB;
        const otherParent = bestParent === parentA ? parentB : parentA;
        const child = new Genome(parentA.config);
        const nodeMap = new Map();
        parentA.nodes.forEach((node, id) => nodeMap.set(id, node));
        parentB.nodes.forEach((node, id) => {
          if (!nodeMap.has(id)) nodeMap.set(id, node);
        });
        child.nodes = new Map();
        nodeMap.forEach((node, id) => {
          child.nodes.set(id, node.clone());
        });
        child.inputIds = Array.from(new Set([...parentA.inputIds, ...parentB.inputIds])).sort((a, b) => a - b);
        child.outputIds = Array.from(new Set([...parentA.outputIds, ...parentB.outputIds])).sort((a, b) => {
          const na = child.nodes.get(a);
          const nb = child.nodes.get(b);
          const ia = na?.outputIndex ?? 0;
          const ib = nb?.outputIndex ?? 0;
          return ia === ib ? a - b : ia - ib;
        });
        child.biasId = parentA.biasId ?? parentB.biasId ?? null;
        child.connections = new Map();
        const innovations = new Set([
          ...parentA.connections.keys(),
          ...parentB.connections.keys()
        ]);
        Array.from(innovations)
          .sort((a, b) => a - b)
          .forEach((innovation) => {
            const geneA = parentA.connections.get(innovation);
            const geneB = parentB.connections.get(innovation);
            let geneToUse = null;
            if (geneA && geneB) {
              geneToUse = Math.random() < 0.5 ? geneA : geneB;
              if (!geneA.enabled || !geneB.enabled) {
                const clone = geneToUse.clone();
                clone.enabled = geneA.enabled && geneB.enabled ? Math.random() < 0.75 : geneA.enabled && geneB.enabled;
                geneToUse = clone;
              }
            } else if (geneA && bestParent === parentA) {
              geneToUse = geneA;
            } else if (geneB && bestParent === parentB) {
              geneToUse = geneB;
            } else if (geneA && geneB) {
              geneToUse = Math.random() < 0.5 ? geneA : geneB;
            }
            if (geneToUse) {
              child.connections.set(geneToUse.innovation, geneToUse.clone());
            }
          });
        child.invalidateCaches();
        return child;
      }
    }
    class Species {
      constructor(id, representative) {
        this.id = id;
        this.representative = representative.clone();
        this.members = [];
        this.age = 0;
        this.maxFitness = -Infinity;
        this.generationsWithoutImprovement = 0;
      }

      addMember(genome) {
        this.members.push(genome);
      }

      finalize() {
        if (!this.members.length) return;
        this.members.sort((a, b) => b.fitness - a.fitness);
        const best = this.members[0];
        if (best.fitness > this.maxFitness + 1e-6) {
          this.maxFitness = best.fitness;
          this.generationsWithoutImprovement = 0;
        } else {
          this.generationsWithoutImprovement += 1;
        }
        this.representative = best.clone();
      }

      averageFitness() {
        if (!this.members.length) return 0;
        const sum = this.members.reduce((acc, g) => acc + g.fitness, 0);
        return sum / this.members.length;
      }

      selectParent() {
        if (!this.members.length) return null;
        const total = this.members.reduce((acc, g) => acc + Math.max(0, g.fitness), 0);
        if (total <= 0) return rand.choice(this.members);
        let threshold = Math.random() * total;
        for (const genome of this.members) {
          threshold -= Math.max(0, genome.fitness);
          if (threshold <= 0) return genome;
        }
        return this.members[this.members.length - 1];
      }
    }

    class NEATPopulation {
      constructor(genomeConfig, neatConfig) {
        this.genomeConfig = genomeConfig;
        this.config = {
          populationSize: neatConfig.populationSize,
          compatibilityThreshold: neatConfig.compatibilityThreshold,
          c1: neatConfig.c1 ?? 1,
          c2: neatConfig.c2 ?? 1,
          c3: neatConfig.c3 ?? 0.4,
          eliteFraction: neatConfig.eliteFraction ?? 0.1
        };
        this.mutation = { ...neatConfig.mutation };
        this.tracker = new InnovationTracker(genomeConfig.inputCount + genomeConfig.outputCount + 1);
        this.genomes = [];
        this.species = [];
        this.bestGenome = null;
        this.generation = 0;
        this.speciesCounter = 0;
        this.initialize();
      }

      initialize() {
        this.genomes = [];
        for (let i = 0; i < this.config.populationSize; i += 1) {
          const genome = Genome.createInitial(this.genomeConfig, this.tracker);
          genome.mutateWeights({ weightProb: 1, sigma: 1, resetProb: 1 });
          this.genomes.push(genome);
        }
        this.species = [];
        this.bestGenome = null;
        this.generation = 0;
      }

      async evaluate(evaluator) {
        let best = null;
        for (let i = 0; i < this.genomes.length; i += 1) {
          const genome = this.genomes[i];
          await evaluator(genome, i, this.genomes.length);
          if (!best || genome.fitness > best.fitness) {
            best = genome;
          }
          if (i % 4 === 0) await waitFrame();
        }
        this.bestGenome = best ? best.clone() : null;
        this.speciate();
        return this.bestGenome;
      }

      speciate() {
        const threshold = this.config.compatibilityThreshold;
        const previous = this.species;
        const reusedIds = new Set();
        const nextSpecies = [];
        for (const genome of this.genomes) {
          let assigned = false;
          for (const species of nextSpecies) {
            const dist = genome.compatibilityDistance(species.representative, this.config);
            if (dist < threshold) {
              species.addMember(genome);
              assigned = true;
              break;
            }
          }
          if (assigned) continue;
          let matched = null;
          for (const old of previous) {
            if (reusedIds.has(old.id)) continue;
            const dist = genome.compatibilityDistance(old.representative, this.config);
            if (dist < threshold) {
              matched = old;
              break;
            }
          }
          if (matched) {
            const species = new Species(matched.id, genome);
            species.age = matched.age + 1;
            species.maxFitness = matched.maxFitness;
            species.generationsWithoutImprovement = matched.generationsWithoutImprovement;
            species.addMember(genome);
            nextSpecies.push(species);
            reusedIds.add(matched.id);
          } else {
            const species = new Species(++this.speciesCounter, genome);
            species.addMember(genome);
            nextSpecies.push(species);
          }
        }
        nextSpecies.forEach((species) => species.finalize());
        this.species = nextSpecies;
      }

      buildSummary() {
        const best = this.bestGenome ? this.bestGenome.clone() : null;
        const totalFitness = this.genomes.reduce((acc, g) => acc + g.fitness, 0);
        const averageFitness = this.genomes.length ? totalFitness / this.genomes.length : 0;
        return {
          generation: this.generation,
          bestFitness: best?.fitness ?? 0,
          averageFitness,
          speciesCount: this.species.length,
          species: this.species.map((spec) => ({
            id: spec.id,
            members: spec.members.length,
            best: spec.members[0]?.fitness ?? 0,
            age: spec.age,
            stagnation: spec.generationsWithoutImprovement
          })),
          champion: best
        };
      }

      evolve() {
        if (!this.species.length) {
          this.initialize();
          this.generation += 1;
          return;
        }
        const nextGen = [];
        const popSize = this.config.populationSize;
        const eliteFraction = this.config.eliteFraction;
        const mutationConfig = this.mutation;
        const sortedSpecies = this.species
          .filter((spec) => spec.members.length)
          .sort((a, b) => (b.members[0]?.fitness ?? 0) - (a.members[0]?.fitness ?? 0));
        const adjusted = sortedSpecies.map((spec) => Math.max(0, spec.averageFitness()));
        const totalAdjusted = adjusted.reduce((acc, val) => acc + val, 0) || 1;
        sortedSpecies.forEach((species, idx) => {
          const avgFitness = adjusted[idx];
          let offspringCount = Math.floor((avgFitness / totalAdjusted) * popSize);
          if (offspringCount <= 0 && idx === 0) offspringCount = 1;
          const elites = Math.max(1, Math.round(eliteFraction * species.members.length));
          for (let i = 0; i < Math.min(elites, species.members.length); i += 1) {
            if (nextGen.length >= popSize) break;
            nextGen.push(species.members[i].clone());
          }
          let remaining = offspringCount - elites;
          if (remaining < 0) remaining = 0;
          for (let i = 0; i < remaining && nextGen.length < popSize; i += 1) {
            const parent1 = species.selectParent();
            const parent2 = species.selectParent();
            let child;
            if (parent1 && parent2 && parent1 !== parent2) {
              child = Genome.crossover(parent1, parent2, this.tracker);
            } else if (parent1) {
              child = parent1.clone();
            } else {
              continue;
            }
            child.mutate(mutationConfig, this.tracker);
            nextGen.push(child);
          }
        });
        while (nextGen.length < popSize) {
          const base = sortedSpecies[0]?.members[0] ?? Genome.createInitial(this.genomeConfig, this.tracker);
          const clone = base.clone();
          clone.mutate(mutationConfig, this.tracker);
          nextGen.push(clone);
        }
        this.genomes = nextGen.slice(0, popSize);
        this.generation += 1;
      }
    }
    const ACTIONS = [
      { x: 0, y: -1 },
      { x: 1, y: 0 },
      { x: 0, y: 1 },
      { x: -1, y: 0 }
    ];

    const actionFromVector = (dx, dy) => {
      for (let i = 0; i < ACTIONS.length; i += 1) {
        if (ACTIONS[i].x === dx && ACTIONS[i].y === dy) return i;
      }
      return null;
    };

    const cellKey = (x, y) => `${x},${y}`;

    const clamp = (value, min, max) => {
      if (value < min) return min;
      if (value > max) return max;
      return value;
    };

    class SnakeEnvironment {
      constructor(cols, rows, options = {}) {
        this.cols = cols;
        this.rows = rows;
        this.rewardConfig = { ...DEFAULT_REWARD_CONFIG, ...(options.rewardConfig || {}) };
        this.maxStepsWithoutFruit = Math.max(cols * rows, cols * rows * 2);
        this.reset();
      }

      setRewardConfig(config = {}) {
        if (!config || typeof config !== 'object') return;
        this.rewardConfig = { ...this.rewardConfig, ...config };
      }

      decayVisitHeatmap() {
        const decay = this.rewardConfig.visitDecay ?? 1;
        if (!this.visit || decay >= 1 || decay <= 0) return;
        for (let i = 0; i < this.visit.length; i += 1) {
          this.visit[i] *= decay;
        }
      }

      buildCoveragePath() {
        const path = [];
        for (let y = 0; y < this.rows; y += 1) {
          if (y % 2 === 0) {
            for (let x = 0; x < this.cols; x += 1) {
              path.push({ x, y });
            }
          } else {
            for (let x = this.cols - 1; x >= 0; x -= 1) {
              path.push({ x, y });
            }
          }
        }
        return path;
      }

      computeCoveragePressure() {
        if (!this.snake || !this.snake.length) return 0;
        const threshold = clamp(this.rewardConfig.coverageStartThreshold ?? 0.6, 0, 0.98);
        const ratio = this.snake.length / Math.max(1, this.cols * this.rows);
        if (ratio <= threshold) return 0;
        const denom = Math.max(1 - threshold, 1e-6);
        return clamp((ratio - threshold) / denom, 0, 1);
      }

      reset(options = {}) {
        if (options.rewardConfig) {
          this.setRewardConfig(options.rewardConfig);
        }
        this.alive = true;
        this.totalSteps = 0;
        this.stepsSinceFruit = 0;
        this.fruits = 0;
        const centerX = Math.max(2, Math.floor(this.cols / 2));
        const centerY = Math.floor(this.rows / 2);
        this.snake = [
          { x: Math.min(this.cols - 1, centerX), y: centerY },
          { x: Math.max(0, centerX - 1), y: centerY },
          { x: Math.max(0, centerX - 2), y: centerY }
        ];
        this.dir = { x: 1, y: 0 };
        this.snakeSet = new Set(this.snake.map((seg) => cellKey(seg.x, seg.y)));
        this.visit = new Float32Array(this.cols * this.rows).fill(0);
        this.headHistory = [];
        this.loopCounter = 0;
        this.helperAlignment = 0;
        this.lastHelperAction = null;
        this.lastBfsDistance = -1;
        this.lastSpaceDelta = 0;
        this.freeSpaceRatio = this.computeReachableRatio();
        this.lastFruitPathDistance = -1;
        this.lastTailPathDistance = -1;
        this.trapCounter = 0;
        this.trapTension = 0;
        this.coveragePath = this.buildCoveragePath();
        this.coverageIndex = new Map();
        this.coveragePath.forEach((point, idx) => {
          this.coverageIndex.set(cellKey(point.x, point.y), idx);
        });
        this.coverageLastIndex = this.coverageIndex.get(cellKey(this.snake[0].x, this.snake[0].y)) ?? 0;
        const coverageLength = Math.max(1, this.coveragePath.length);
        this.coverageExpectedIndex = (this.coverageLastIndex + 1) % coverageLength;
        this.coverageDelta = 0;
        this.coverageAligned = 1;
        this.coveragePressure = 0;
        this.placeFruit();
        this.lastBfsDistance = computeBfsDistance(
          { cols: this.cols, rows: this.rows },
          this.snake,
          this.fruit,
          { allowTail: true }
        );
        this.lastFruitPathDistance = this.lastBfsDistance;
        const tailTarget = this.snake[this.snake.length - 1];
        this.lastTailPathDistance = this.snake.length > 1
          ? computeBfsDistance({ cols: this.cols, rows: this.rows }, this.snake, tailTarget, { allowTail: true })
          : 0;
        return this.getState();
      }

      placeFruit() {
        const free = [];
        for (let y = 0; y < this.rows; y += 1) {
          for (let x = 0; x < this.cols; x += 1) {
            const key = cellKey(x, y);
            if (!this.snakeSet.has(key)) free.push({ x, y });
          }
        }
        if (!free.length) {
          this.fruit = null;
          return;
        }
        this.fruit = rand.choice(free);
      }

      outOfBounds(x, y) {
        return x < 0 || y < 0 || x >= this.cols || y >= this.rows;
      }

      applyAction(action) {
        const move = ACTIONS[action] ?? this.dir;
        const opposite = { x: -this.dir.x, y: -this.dir.y };
        if (move.x === opposite.x && move.y === opposite.y) return;
        this.dir = move;
      }

      computeReachableRatio(allowTail = true) {
        if (!this.snake.length) return 0;
        const head = this.snake[0];
        const visited = new Set();
        const queue = [{ x: head.x, y: head.y }];
        let qIndex = 0;
        visited.add(cellKey(head.x, head.y));
        const blocked = new Set(this.snakeSet);
        if (allowTail && this.snake.length) {
          const tail = this.snake[this.snake.length - 1];
          blocked.delete(cellKey(tail.x, tail.y));
        }
        let count = 0;
        while (qIndex < queue.length) {
          const current = queue[qIndex++];
          count += 1;
          for (const dir of ACTIONS) {
            const nx = current.x + dir.x;
            const ny = current.y + dir.y;
            if (nx < 0 || ny < 0 || nx >= this.cols || ny >= this.rows) continue;
            const key = cellKey(nx, ny);
            if (visited.has(key)) continue;
            if (blocked.has(key)) continue;
            visited.add(key);
            queue.push({ x: nx, y: ny });
          }
        }
        return count / (this.cols * this.rows);
      }

      getBfsSuggestion(allowTail = true) {
        if (!this.fruit || this.fruit.x < 0 || this.fruit.y < 0) {
          return { action: null, distance: -1 };
        }
        try {
          const path = computeBfsPath({ cols: this.cols, rows: this.rows }, this.snake, this.fruit, { allowTail });
          if (!Array.isArray(path) || !path.length) {
            return { action: null, distance: -1 };
          }
          const distance = path.length - 1;
          if (path.length <= 1) {
            return { action: null, distance };
          }
          const nextStep = path[1];
          const dx = nextStep.x - this.snake[0].x;
          const dy = nextStep.y - this.snake[0].y;
          return { action: actionFromVector(dx, dy), distance };
        } catch (err) {
          return { action: null, distance: -1 };
        }
      }

      step(action) {
        if (!this.alive) {
          return { state: this.getState(), reward: 0, done: true, info: { crash: 'dead', ateFruit: false } };
        }
        const cfg = this.rewardConfig;
        const head = this.snake[0];
        const headKey = cellKey(head.x, head.y);
        const prevDistance = this.fruit ? Math.abs(this.fruit.x - head.x) + Math.abs(this.fruit.y - head.y) : 0;
        const prevFruitPath = this.lastFruitPathDistance;
        const prevTailPath = this.lastTailPathDistance;
        const prevCoverageIndex = this.coverageIndex ? this.coverageIndex.get(headKey) : null;
        this.decayVisitHeatmap();
        this.applyAction(action);
        const move = this.dir;
        const next = { x: head.x + move.x, y: head.y + move.y };
        const nextKey = cellKey(next.x, next.y);
        const tail = this.snake[this.snake.length - 1];
        const tailKey = cellKey(tail.x, tail.y);
        const willGrow = this.fruit && next.x === this.fruit.x && next.y === this.fruit.y;
        const hitsWall = this.outOfBounds(next.x, next.y);
        const hitsBody = this.snakeSet.has(nextKey) && !(nextKey === tailKey && !willGrow);
        let reward = -cfg.stepPenalty;
        if (hitsWall || hitsBody) {
          this.alive = false;
          reward -= hitsWall ? cfg.wallPenalty : cfg.selfPenalty;
          return {
            state: this.getState(),
            reward,
            done: true,
            info: { crash: hitsWall ? 'wall' : 'self', ateFruit: false }
          };
        }
        const suggestion = this.getBfsSuggestion(!willGrow);
        this.lastHelperAction = suggestion.action;
        this.lastBfsDistance = suggestion.distance;
        this.snake.unshift(next);
        this.snakeSet.add(nextKey);
        let ateFruit = false;
        if (willGrow) {
          ateFruit = true;
          reward += cfg.fruitReward;
          this.fruits += 1;
          this.stepsSinceFruit = 0;
          if (this.snake.length < this.cols * this.rows) {
            this.placeFruit();
          } else {
            this.fruit = null;
          }
        } else {
          const removed = this.snake.pop();
          this.snakeSet.delete(cellKey(removed.x, removed.y));
          this.stepsSinceFruit += 1;
          if (cfg.tailChaseBonus) {
            const tailBefore = Math.abs(head.x - tail.x) + Math.abs(head.y - tail.y);
            const tailAfter = Math.abs(next.x - removed.x) + Math.abs(next.y - removed.y);
            if (tailBefore > tailAfter) {
              const threshold = cfg.tailPressureThreshold ?? 0.15;
              const pressure = clamp((threshold - this.freeSpaceRatio) / Math.max(threshold, 1e-6), 0, 1);
              if (pressure > 0) {
                reward += cfg.tailChaseBonus * (tailBefore - tailAfter) * pressure;
              }
            }
          }
        }
        const coverageLen = this.coveragePath?.length ?? 0;
        if (coverageLen > 0 && this.coverageIndex) {
          const nextCoverageIndex = this.coverageIndex.get(nextKey);
          const expectedIndex = Number.isInteger(prevCoverageIndex)
            ? (prevCoverageIndex + 1) % coverageLen
            : nextCoverageIndex ?? 0;
          const rawDelta = Number.isInteger(nextCoverageIndex)
            ? (nextCoverageIndex - expectedIndex + coverageLen) % coverageLen
            : 0;
          const deviation = rawDelta === 0 ? 0 : Math.min(rawDelta, coverageLen - rawDelta);
          const pressure = this.computeCoveragePressure();
          this.coveragePressure = pressure;
          if (Number.isInteger(nextCoverageIndex)) {
            this.coverageLastIndex = nextCoverageIndex;
            this.coverageExpectedIndex = (nextCoverageIndex + 1) % coverageLen;
          }
          this.coverageDelta = deviation;
          this.coverageAligned = deviation === 0 ? 1 : 0;
          if (pressure > 0) {
            if (deviation === 0) {
              reward += pressure * (cfg.coverageAdvanceReward ?? 0);
            } else {
              reward -= pressure * deviation * (cfg.coverageDeviationPenalty ?? 0);
            }
          }
        } else {
          this.coveragePressure = 0;
          this.coverageDelta = 0;
          this.coverageAligned = 1;
        }
        const fruitDistance = this.fruit
          ? computeBfsDistance({ cols: this.cols, rows: this.rows }, this.snake, this.fruit, { allowTail: !willGrow })
          : -1;
        const tailTargetAfterMove = this.snake[this.snake.length - 1];
        const tailDistance = this.snake.length > 1
          ? computeBfsDistance({ cols: this.cols, rows: this.rows }, this.snake, tailTargetAfterMove, { allowTail: true })
          : 0;
        const fruitPathMissing = Boolean(this.fruit) && fruitDistance < 0;
        const tailPathMissing = this.snake.length > 1 && tailDistance < 0;
        if (fruitDistance >= 0 && prevFruitPath >= 0) {
          const diff = prevFruitPath - fruitDistance;
          if (diff !== 0) {
            const weight = diff > 0 ? (cfg.fruitPathBonus ?? 0) : (cfg.pathLossPenalty ?? cfg.fruitPathBonus ?? 0);
            reward += diff * weight;
          }
        } else if (fruitDistance >= 0 && prevFruitPath < 0) {
          reward += cfg.pathRecoveryBonus ?? 0;
        } else if (fruitPathMissing) {
          reward -= cfg.noFruitPathPenalty ?? 0;
        }
        if (tailDistance >= 0 && prevTailPath >= 0) {
          const diffTail = prevTailPath - tailDistance;
          if (diffTail !== 0) {
            const weightTail = diffTail > 0 ? (cfg.tailPathBonus ?? 0) : (cfg.pathLossPenalty ?? cfg.tailPathBonus ?? 0);
            reward += diffTail * weightTail;
          }
        } else if (tailDistance >= 0 && prevTailPath < 0) {
          reward += (cfg.pathRecoveryBonus ?? 0) * 0.5;
        } else if (tailPathMissing) {
          reward -= cfg.noTailPathPenalty ?? 0;
        }
        this.lastFruitPathDistance = fruitDistance;
        this.lastTailPathDistance = tailDistance;
        this.totalSteps += 1;
        const nextDistance = this.fruit ? Math.abs(this.fruit.x - next.x) + Math.abs(this.fruit.y - next.y) : prevDistance;
        if (nextDistance < prevDistance) {
          reward += cfg.approachBonus;
        } else if (nextDistance > prevDistance) {
          reward -= cfg.retreatPenalty;
        }
        if (this.stepsSinceFruit && this.stepsSinceFruit % Math.max(35, Math.floor(this.cols * 1.25)) === 0) {
          reward -= cfg.idlePenalty;
        }
        if (this.lastHelperAction !== null && cfg.helperWeight) {
          if (action === this.lastHelperAction) {
            reward += cfg.helperWeight;
            this.helperAlignment = 1;
          } else {
            reward -= Math.abs(cfg.helperWeight) * (cfg.helperPenalty ?? 0.5);
            this.helperAlignment = -1;
          }
        } else {
          this.helperAlignment = 0;
        }
        const index = next.y * this.cols + next.x;
        if (index >= 0 && index < this.visit.length) {
          const revisit = this.visit[index];
          if (revisit > 0) {
            reward -= revisit * cfg.revisitPenalty;
          }
          this.visit[index] = clamp(revisit + (cfg.revisitIncrement ?? 0.2), 0, 1);
        }
        const currentKey = cellKey(next.x, next.y);
        this.headHistory.push(currentKey);
        if (this.headHistory.length > LOOP_HISTORY_LIMIT) {
          this.headHistory.shift();
        }
        const duplicates = this.headHistory.filter((key) => key === currentKey).length;
        if (duplicates > 1) {
          reward -= cfg.loopPenalty * (duplicates - 1);
          this.loopCounter = Math.min(LOOP_HISTORY_LIMIT, this.loopCounter + duplicates);
        } else {
          this.loopCounter = Math.max(0, this.loopCounter - 0.5);
        }
        const previousRatio = this.freeSpaceRatio;
        this.freeSpaceRatio = this.computeReachableRatio(!willGrow);
        this.lastSpaceDelta = this.freeSpaceRatio - previousRatio;
        if (this.lastSpaceDelta > 0) {
          reward += this.lastSpaceDelta * (cfg.spaceGainReward ?? 1);
        } else if (this.lastSpaceDelta < 0) {
          reward += this.lastSpaceDelta * (cfg.spaceLossPenalty ?? 1);
        }
        const trapLimit = Math.max(1, cfg.trapCounterLimit ?? 8);
        if (fruitPathMissing || tailPathMissing || this.freeSpaceRatio < (cfg.trapThreshold ?? 0.12)) {
          this.trapCounter += 1;
          const tension = clamp(this.trapCounter / trapLimit, 0, 1);
          this.trapTension = tension;
          reward -= tension * (cfg.trapPenalty ?? 0);
        } else {
          this.trapCounter = Math.max(0, this.trapCounter - 1);
          this.trapTension = clamp(this.trapCounter / trapLimit, 0, 1);
        }
        if (this.snake.length >= this.cols * this.rows) {
          this.alive = false;
          reward += cfg.victoryReward;
          return { state: this.getState(), reward, done: true, info: { crash: 'victory', ateFruit: true } };
        }
        if (this.stepsSinceFruit > this.maxStepsWithoutFruit) {
          this.alive = false;
          reward -= cfg.timeoutPenalty;
          return { state: this.getState(), reward, done: true, info: { crash: 'timeout', ateFruit } };
        }
        return { state: this.getState(), reward, done: false, info: { crash: null, ateFruit } };
      }

      distanceUntilHit(dir) {
        const head = this.snake[0];
        let x = head.x;
        let y = head.y;
        let dist = 0;
        const limit = Math.max(this.cols, this.rows);
        while (dist < limit) {
          x += dir.x;
          y += dir.y;
          const key = cellKey(x, y);
          if (this.outOfBounds(x, y)) break;
          if (this.snakeSet.has(key)) break;
          dist += 1;
        }
        return dist / limit;
      }

      getState() {
        const head = this.snake[0];
        const fruit = this.fruit ?? head;
        const dir = this.dir;
        const left = { x: -dir.y, y: dir.x };
        const right = { x: dir.y, y: -dir.x };
        const back = { x: -dir.x, y: -dir.y };
        const forward = { x: head.x + dir.x, y: head.y + dir.y };
        const leftCell = { x: head.x + left.x, y: head.y + left.y };
        const rightCell = { x: head.x + right.x, y: head.y + right.y };
        const tail = this.snake[this.snake.length - 1];
        const tailKey = cellKey(tail.x, tail.y);

        const checkDanger = (cell) => {
          const key = cellKey(cell.x, cell.y);
          return this.outOfBounds(cell.x, cell.y)
            || (this.snakeSet.has(key) && key !== tailKey);
        };

        const dangerAhead = this.outOfBounds(forward.x, forward.y)
          || (this.snakeSet.has(cellKey(forward.x, forward.y)) && cellKey(forward.x, forward.y) !== tailKey);
        const dangerLeft = this.outOfBounds(leftCell.x, leftCell.y)
          || (this.snakeSet.has(cellKey(leftCell.x, leftCell.y)) && cellKey(leftCell.x, leftCell.y) !== tailKey);
        const dangerRight = this.outOfBounds(rightCell.x, rightCell.y)
          || (this.snakeSet.has(cellKey(rightCell.x, rightCell.y)) && cellKey(rightCell.x, rightCell.y) !== tailKey);
        const dangerBack = checkDanger({ x: head.x + back.x, y: head.y + back.y });
        const frontLeft = { x: head.x + dir.x + left.x, y: head.y + dir.y + left.y };
        const frontRight = { x: head.x + dir.x + right.x, y: head.y + dir.y + right.y };
        const backLeft = { x: head.x + back.x + left.x, y: head.y + back.y + left.y };
        const backRight = { x: head.x + back.x + right.x, y: head.y + back.y + right.y };
        const dangerFrontLeft = checkDanger(frontLeft);
        const dangerFrontRight = checkDanger(frontRight);
        const dangerBackLeft = checkDanger(backLeft);
        const dangerBackRight = checkDanger(backRight);

        const immediateFreeRatio = (
          (!dangerAhead ? 1 : 0)
          + (!dangerLeft ? 1 : 0)
          + (!dangerRight ? 1 : 0)
          + (!dangerBack ? 1 : 0)
        ) / 4;

        const direction = [
          dir.y === -1 ? 1 : 0,
          dir.x === 1 ? 1 : 0,
          dir.y === 1 ? 1 : 0,
          dir.x === -1 ? 1 : 0
        ];
        const fruitDir = [
          fruit.y < head.y ? 1 : 0,
          fruit.x > head.x ? 1 : 0,
          fruit.y > head.y ? 1 : 0,
          fruit.x < head.x ? 1 : 0
        ];
        const norm = (value, max) => (max <= 0 ? 0 : value / max);
        const normX = this.cols - 1;
        const normY = this.rows - 1;
        const top = norm(head.y, normY);
        const bottom = norm(normY - head.y, normY);
        const leftDist = norm(head.x, normX);
        const rightDist = norm(normX - head.x, normX);
        const fruitDx = norm(fruit.x - head.x, normX);
        const fruitDy = norm(fruit.y - head.y, normY);
        const manhattan = (Math.abs(fruit.x - head.x) + Math.abs(fruit.y - head.y)) / (this.cols + this.rows);
        const maxDiag = Math.hypot(Math.max(1, this.cols - 1), Math.max(1, this.rows - 1));
        const deltaX = fruit.x - head.x;
        const deltaY = fruit.y - head.y;
        const euclidean = maxDiag ? Math.hypot(deltaX, deltaY) / maxDiag : 0;
        const dot = deltaX * dir.x + deltaY * dir.y;
        const det = dir.x * deltaY - dir.y * deltaX;
        const hyp = Math.hypot(deltaX, deltaY) || 1;
        const fruitCos = dot / hyp;
        const fruitSin = det / hyp;
        const forwardProjection = Math.max(0, dot) / hyp;
        const tailDistance = maxDiag ? Math.hypot(tail.x - head.x, tail.y - head.y) / maxDiag : 0;
        const lengthNorm = this.snake.length / (this.cols * this.rows);
        const stepsNorm = this.stepsSinceFruit / this.maxStepsWithoutFruit;
        const distForward = this.distanceUntilHit(dir);
        const distLeft = this.distanceUntilHit(left);
        const distRight = this.distanceUntilHit(right);
        const freeSpaceRatio = clamp(this.freeSpaceRatio ?? 0, 0, 1);
        const loopPressure = clamp(this.loopCounter / LOOP_HISTORY_LIMIT, 0, 1);
        const spaceDelta = clamp(this.lastSpaceDelta ?? 0, -1, 1);
        const helperAvailable = this.lastHelperAction === null ? 0 : 1;
        const bfsCloseness = this.lastBfsDistance >= 0
          ? 1 - clamp(this.lastBfsDistance / (this.cols + this.rows), 0, 1)
          : -1;
        const maxGridMetric = Math.max(1, this.cols + this.rows);
        const fruitPathDistance = this.lastFruitPathDistance ?? -1;
        const tailPathDistanceSteps = this.lastTailPathDistance ?? -1;
        const fruitPathAvailable = fruitPathDistance >= 0 ? 1 : 0;
        const tailPathAvailable = tailPathDistanceSteps >= 0 ? 1 : 0;
        const fruitPathCloseness = fruitPathDistance >= 0
          ? 1 - clamp(fruitPathDistance / maxGridMetric, 0, 1)
          : -1;
        const tailPathCloseness = tailPathDistanceSteps >= 0
          ? 1 - clamp(tailPathDistanceSteps / maxGridMetric, 0, 1)
          : -1;
        const trapTension = clamp(this.trapTension ?? 0, 0, 1);
        const coverageLen = this.coveragePath?.length ?? 0;
        const coverageProgress = coverageLen > 1
          ? clamp((this.coverageLastIndex ?? 0) / (coverageLen - 1), 0, 1)
          : 0;
        const coverageDelta = coverageLen > 0
          ? clamp(this.coverageDelta ?? 0, 0, coverageLen) / Math.max(1, coverageLen)
          : 0;
        const coveragePressure = clamp(this.coveragePressure ?? 0, 0, 1);
        const coverageAligned = this.coverageAligned ?? 0;
        const coverageNextIndex = this.coverageExpectedIndex ?? 0;
        const coverageNextNorm = coverageLen > 0
          ? clamp(coverageNextIndex / coverageLen, 0, 1)
          : 0;

        const features = [
          dangerAhead ? 1 : 0,
          dangerLeft ? 1 : 0,
          dangerRight ? 1 : 0,
          dangerBack ? 1 : 0,
          dangerFrontLeft ? 1 : 0,
          dangerFrontRight ? 1 : 0,
          dangerBackLeft ? 1 : 0,
          dangerBackRight ? 1 : 0,
          ...direction,
          ...fruitDir,
          top,
          rightDist,
          bottom,
          leftDist,
          fruitDx,
          fruitDy,
          manhattan,
          euclidean,
          fruitCos,
          fruitSin,
          forwardProjection,
          tailDistance,
          immediateFreeRatio,
          lengthNorm,
          stepsNorm,
          distForward,
          distLeft,
          distRight,
          freeSpaceRatio,
          spaceDelta,
          this.helperAlignment,
          helperAvailable,
          loopPressure,
          bfsCloseness,
          fruitPathAvailable,
          tailPathAvailable,
          fruitPathCloseness,
          tailPathCloseness,
          trapTension,
          coverageProgress,
          coverageDelta,
          coveragePressure,
          coverageAligned,
          coverageNextNorm
        ];
        return Float32Array.from(features);
      }
    }

    const waitFrame = () => new Promise((resolve) => requestAnimationFrame(() => resolve()));
    const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
    class NEATAgent {
      constructor(genomeConfig, neatConfig, evalConfig) {
        this.genomeConfig = genomeConfig;
        const { rewardConfig = {}, ...restEval } = evalConfig || {};
        this.evalConfig = {
          ...restEval,
          rewardConfig: { ...DEFAULT_REWARD_CONFIG, ...rewardConfig }
        };
        this.population = new NEATPopulation(genomeConfig, neatConfig);
        this.bestGenome = null;
        this.stopRequested = false;
        this.paused = false;
        this.loopPromise = null;
      }

      updateEvaluationConfig(opts = {}) {
        const { rewardConfig, ...rest } = opts || {};
        Object.assign(this.evalConfig, rest);
        if (rewardConfig && typeof rewardConfig === 'object') {
          this.evalConfig.rewardConfig = {
            ...this.evalConfig.rewardConfig,
            ...rewardConfig
          };
        }
      }

      async evaluateGenome(genome) {
        const episodes = Math.max(1, this.evalConfig.episodes | 0);
        const maxSteps = Math.max(50, this.evalConfig.maxSteps | 0);
        const fruitBonus = this.evalConfig.fruitBonus ?? 4;
        const winBonus = this.evalConfig.winBonus ?? 0;
        const cols = Math.max(4, this.evalConfig.cols | 0);
        const rows = Math.max(4, this.evalConfig.rows | 0);
        const rewardConfig = this.evalConfig.rewardConfig || DEFAULT_REWARD_CONFIG;
        let totalReward = 0;
        let totalFruits = 0;
        let totalSteps = 0;
        for (let ep = 0; ep < episodes; ep += 1) {
          const env = new SnakeEnvironment(cols, rows, { rewardConfig });
          let state = env.reset();
          let rewardSum = 0;
          let won = false;
          for (let step = 0; step < maxSteps; step += 1) {
            const { action } = genome.decideAction(state);
            const result = env.step(action);
            state = result.state;
            rewardSum += result.reward;
            if (result.done) {
              if (env.snake.length >= cols * rows) {
                won = true;
              }
              break;
            }
          }
          if (won) {
            rewardSum += winBonus;
          }
          totalReward += rewardSum;
          totalFruits += env.fruits;
          totalSteps += Math.min(env.totalSteps, maxSteps);
        }
        const avgReward = totalReward / episodes;
        const avgFruit = totalFruits / episodes;
        const avgSteps = totalSteps / episodes;
        genome.fitness = avgReward + avgFruit * fruitBonus;
        genome.stats = { reward: avgReward, fruits: avgFruit, steps: avgSteps };
        return genome;
      }

      async stepGeneration(onUpdate) {
        await this.population.evaluate(async (genome, index, total) => {
          await this.evaluateGenome(genome);
          if (index % 2 === 0) await waitFrame();
        });
        const summary = this.population.buildSummary();
        this.bestGenome = summary.champion ? summary.champion.clone() : null;
        if (onUpdate) onUpdate(summary);
        this.population.evolve();
        return summary;
      }

      async start(onUpdate) {
        if (this.loopPromise) return this.loopPromise;
        this.stopRequested = false;
        this.paused = false;
        const runLoop = async () => {
          while (!this.stopRequested) {
            if (this.paused) {
              await sleep(50);
              continue;
            }
            await this.stepGeneration(onUpdate);
          }
        };
        this.loopPromise = runLoop().finally(() => {
          this.loopPromise = null;
        });
        return this.loopPromise;
      }

      pause() {
        this.paused = true;
      }

      resume() {
        this.paused = false;
      }

      async stop() {
        this.stopRequested = true;
        if (this.loopPromise) {
          await this.loopPromise;
        }
      }
    }
    const ui = {
      statusBadge: document.getElementById('statusBadge'),
      generationBadge: document.getElementById('generationBadge'),
      speciesBadge: document.getElementById('speciesBadge'),
      statGeneration: document.getElementById('statGeneration'),
      statBestFitness: document.getElementById('statBestFitness'),
      statAvgFitness: document.getElementById('statAvgFitness'),
      statImproved: document.getElementById('statImproved'),
      statFruit: document.getElementById('statFruit'),
      statSteps: document.getElementById('statSteps'),
      eventLog: document.getElementById('eventLog'),
      watchBtn: document.getElementById('watchBtn'),
      startBtn: document.getElementById('startBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      stepBtn: document.getElementById('stepBtn'),
      gridSize: document.getElementById('gridSize'),
      gridReadout: document.getElementById('gridReadout'),
      maxSteps: document.getElementById('maxSteps'),
      episodeCount: document.getElementById('episodeCount'),
      populationSize: document.getElementById('populationSize'),
      eliteFraction: document.getElementById('eliteFraction'),
      compatThreshold: document.getElementById('compatThreshold'),
      weightSigma: document.getElementById('weightSigma'),
      weightProb: document.getElementById('weightProb'),
      linkProb: document.getElementById('linkProb'),
      nodeProb: document.getElementById('nodeProb'),
      toggleProb: document.getElementById('toggleProb'),
      speciesList: document.getElementById('speciesList')
    };

    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');

    let agent = null;
    let trainingActive = false;
    let watching = false;
    let watchCancel = null;
    let lastBestFitness = -Infinity;
    let lastImprovementGen = 0;

    function logEvent(message) {
      if (!ui.eventLog) return;
      const time = new Date().toLocaleTimeString();
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      entry.innerHTML = `<strong>[${time}]</strong> ${message}`;
      ui.eventLog.prepend(entry);
      while (ui.eventLog.children.length > 60) {
        ui.eventLog.removeChild(ui.eventLog.lastChild);
      }
    }

    function updateStatus(label, variant = 'default') {
      if (!ui.statusBadge) return;
      ui.statusBadge.textContent = `Status: ${label}`;
      ui.statusBadge.classList.toggle('success', variant === 'success');
    }

    function setControlsRunning(running) {
      trainingActive = running;
      ui.startBtn.textContent = running ? 'Stoppa träning' : 'Starta träning';
      ui.pauseBtn.disabled = !running;
      ui.stepBtn.disabled = running;
      ui.gridSize.disabled = running;
      ui.maxSteps.disabled = running;
      ui.episodeCount.disabled = running;
      ui.populationSize.disabled = running;
      ui.eliteFraction.disabled = running;
      ui.compatThreshold.disabled = running;
      ui.weightSigma.disabled = running;
      ui.weightProb.disabled = running;
      ui.linkProb.disabled = running;
      ui.nodeProb.disabled = running;
      ui.toggleProb.disabled = running;
      if (!running) {
        ui.pauseBtn.textContent = 'Pausa';
      }
    }

    function updateStats(summary) {
      if (!summary) return;
      ui.statGeneration.textContent = `${summary.generation}`;
      ui.statBestFitness.textContent = summary.bestFitness.toFixed(2);
      ui.statAvgFitness.textContent = summary.averageFitness.toFixed(2);
      ui.statFruit.textContent = summary.champion?.stats?.fruits?.toFixed(2) ?? '0.00';
      ui.statSteps.textContent = summary.champion?.stats?.steps?.toFixed(1) ?? '0.0';
      ui.generationBadge.textContent = `Generation ${summary.generation}`;
      ui.speciesBadge.textContent = `Arter ${summary.speciesCount}`;
    }

    function updateSpeciesList(species) {
      if (!ui.speciesList) return;
      ui.speciesList.innerHTML = '';
      if (!Array.isArray(species) || !species.length) {
        const li = document.createElement('li');
        li.textContent = 'Inga arter ännu.';
        ui.speciesList.appendChild(li);
        return;
      }
      species.forEach((spec) => {
        const li = document.createElement('li');
        const best = Number.isFinite(spec.best) ? spec.best.toFixed(1) : '0.0';
        li.innerHTML = `<span>Art ${spec.id}</span><span>${spec.members} indiv.</span><span>Top ${best}</span>`;
        ui.speciesList.appendChild(li);
      });
    }

    function drawEnvironment(env) {
      if (!ctx || !env) return;
      const size = canvas.width;
      ctx.clearRect(0, 0, size, size);
      const padding = 24;
      const usable = size - padding * 2;
      const cell = usable / Math.max(env.cols, env.rows);
      const boardWidth = cell * env.cols;
      const boardHeight = cell * env.rows;
      const offsetX = (size - boardWidth) / 2;
      const offsetY = (size - boardHeight) / 2;

      const gradient = ctx.createLinearGradient(0, 0, size, size);
      gradient.addColorStop(0, '#121632');
      gradient.addColorStop(1, '#0b1024');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);

      ctx.strokeStyle = 'rgba(108, 122, 200, 0.16)';
      ctx.lineWidth = 1;
      for (let c = 0; c <= env.cols; c += 1) {
        const x = offsetX + c * cell;
        ctx.beginPath();
        ctx.moveTo(x, offsetY);
        ctx.lineTo(x, offsetY + boardHeight);
        ctx.stroke();
      }
      for (let r = 0; r <= env.rows; r += 1) {
        const y = offsetY + r * cell;
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + boardWidth, y);
        ctx.stroke();
      }

      ctx.fillStyle = 'rgba(139, 92, 246, 0.75)';
      env.snake.forEach((segment, index) => {
        const x = offsetX + segment.x * cell;
        const y = offsetY + segment.y * cell;
        const inset = index === 0 ? 3 : 4;
        ctx.fillStyle = index === 0 ? '#f472b6' : 'rgba(139, 92, 246, 0.75)';
        ctx.fillRect(x + inset, y + inset, cell - inset * 2, cell - inset * 2);
        if (index === 0) {
          ctx.fillStyle = '#fde2ff';
          ctx.beginPath();
          ctx.arc(x + cell * 0.65, y + cell * 0.35, Math.max(2, cell * 0.08), 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + cell * 0.65, y + cell * 0.7, Math.max(2, cell * 0.08), 0, Math.PI * 2);
          ctx.fill();
        }
      });

      if (env.fruit) {
        const fx = offsetX + env.fruit.x * cell + cell / 2;
        const fy = offsetY + env.fruit.y * cell + cell / 2;
        ctx.fillStyle = '#fb7185';
        ctx.beginPath();
        ctx.arc(fx, fy, Math.max(cell / 3, 6), 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = '#22c55e';
        ctx.beginPath();
        ctx.ellipse(fx, fy - cell / 3, Math.max(2, cell / 6), Math.max(1.5, cell / 10), 0, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawEmptyBoard(size = Number(ui.gridSize.value || 14)) {
      const rewardConfig = agent?.evalConfig?.rewardConfig || DEFAULT_REWARD_CONFIG;
      const env = new SnakeEnvironment(size, size, { rewardConfig });
      drawEnvironment(env);
    }

    function previewChampion(genome) {
      if (!genome || watching) return;
      const size = Number(ui.gridSize.value || 14);
      const rewardConfig = agent?.evalConfig?.rewardConfig || DEFAULT_REWARD_CONFIG;
      const env = new SnakeEnvironment(size, size, { rewardConfig });
      let state = env.reset();
      const maxSteps = Math.min(120, ui.maxSteps.value ? Number(ui.maxSteps.value) : 400);
      for (let i = 0; i < maxSteps; i += 1) {
        const { action } = genome.decideAction(state);
        const result = env.step(action);
        state = result.state;
        if (result.done) break;
      }
      drawEnvironment(env);
    }
    function syncEvalConfig() {
      if (!agent) return;
      const size = Number(ui.gridSize.value || 14);
      agent.updateEvaluationConfig({
        cols: size,
        rows: size,
        episodes: Number(ui.episodeCount.value || 3),
        maxSteps: Number(ui.maxSteps.value || 600)
      });
    }

    function createAgent() {
      const size = Number(ui.gridSize.value || 14);
      const evalRewardConfig = { ...DEFAULT_REWARD_CONFIG };
      const probeEnv = new SnakeEnvironment(size, size, { rewardConfig: evalRewardConfig });
      const stateSize = probeEnv.reset().length;
      const genomeConfig = { inputCount: stateSize, outputCount: ACTIONS.length };
      const neatConfig = {
        populationSize: Number(ui.populationSize.value || 60),
        compatibilityThreshold: Number(ui.compatThreshold.value || 3.0),
        c1: 1,
        c2: 1,
        c3: 0.4,
        eliteFraction: Number(ui.eliteFraction.value || 0.15),
        mutation: {
          weightProb: Number(ui.weightProb.value || 0.8),
          sigma: Number(ui.weightSigma.value || 0.5),
          resetProb: 0.1,
          addConnectionProb: Number(ui.linkProb.value || 0.3),
          addNodeProb: Number(ui.nodeProb.value || 0.2),
          toggleConnectionProb: Number(ui.toggleProb.value || 0.05)
        }
      };
      const evalConfig = {
        cols: size,
        rows: size,
        episodes: Number(ui.episodeCount.value || 3),
        maxSteps: Number(ui.maxSteps.value || 600),
        fruitBonus: 6,
        winBonus: 50,
        rewardConfig: evalRewardConfig
      };
      agent = new NEATAgent(genomeConfig, neatConfig, evalConfig);
      stopWatch();
      lastBestFitness = -Infinity;
      lastImprovementGen = 0;
      logEvent(`Ny population på ${neatConfig.populationSize} individer initierad (${size}×${size}).`);
      drawEnvironment(probeEnv);
      return agent;
    }

    function ensureAgent() {
      if (!agent) {
        createAgent();
      }
      return agent;
    }

    function handleSummary(summary) {
      if (!summary) return;
      updateStats(summary);
      updateSpeciesList(summary.species);
      if (summary.bestFitness > lastBestFitness + 1e-6) {
        lastBestFitness = summary.bestFitness;
        lastImprovementGen = summary.generation;
        logEvent(`Ny toppfitness: ${summary.bestFitness.toFixed(2)} (generation ${summary.generation}).`);
      }
      ui.statImproved.textContent = lastImprovementGen ? `Gen ${lastImprovementGen}` : '–';
      if (summary.champion) {
        previewChampion(summary.champion);
      }
    }

    async function startWatch(genome) {
      if (!genome) {
        logEvent('Ingen champion att visa ännu.');
        return;
      }
      stopWatch();
      watching = true;
      ui.watchBtn.textContent = 'Stoppa visning';
      let cancelled = false;
      watchCancel = () => {
        cancelled = true;
        watching = false;
        ui.watchBtn.textContent = 'Titta på bästa';
      };
      const size = Number(ui.gridSize.value || 14);
      const rewardConfig = agent?.evalConfig?.rewardConfig || DEFAULT_REWARD_CONFIG;
      const env = new SnakeEnvironment(size, size, { rewardConfig });
      let state = env.reset();
      drawEnvironment(env);
      while (!cancelled) {
        const { action } = genome.decideAction(state);
        const result = env.step(action);
        state = result.state;
        drawEnvironment(env);
        if (result.done) {
          await sleep(400);
          state = env.reset();
          drawEnvironment(env);
        }
        await sleep(80);
      }
    }

    function stopWatch() {
      if (watchCancel) {
        const cancel = watchCancel;
        watchCancel = null;
        cancel();
      }
      watching = false;
      ui.watchBtn.textContent = 'Titta på bästa';
    }

    function invalidateAgent(reason) {
      if (trainingActive) return;
      agent = null;
      logEvent(`${reason} ändrad – ny population kommer att initieras.`);
    }

    ui.gridSize.addEventListener('input', () => {
      ui.gridReadout.textContent = `${ui.gridSize.value}×${ui.gridSize.value}`;
      if (!trainingActive) {
        drawEmptyBoard(Number(ui.gridSize.value));
        if (agent) agent.updateEvaluationConfig({ cols: Number(ui.gridSize.value), rows: Number(ui.gridSize.value) });
      }
    });

    [ui.maxSteps, ui.episodeCount].forEach((input) => {
      input.addEventListener('change', () => {
        syncEvalConfig();
        if (!trainingActive && agent) {
          logEvent('Utvärderingsparametrar uppdaterade.');
        }
      });
    });

    [ui.populationSize, ui.eliteFraction, ui.compatThreshold, ui.weightSigma, ui.weightProb, ui.linkProb, ui.nodeProb, ui.toggleProb].forEach((input) => {
      input.addEventListener('change', () => invalidateAgent(input.previousLabel || input.id));
    });

    ui.startBtn.addEventListener('click', () => {
      if (!trainingActive) {
        ensureAgent();
        syncEvalConfig();
        setControlsRunning(true);
        updateStatus('tränar', 'success');
        logEvent('Träning startar...');
        agent.start(handleSummary).finally(() => {
          setControlsRunning(false);
          updateStatus('idle');
          logEvent('Träning stoppad.');
        });
      } else {
        updateStatus('stoppar');
        logEvent('Stoppar träning...');
        agent?.stop().then(() => {
          setControlsRunning(false);
          updateStatus('idle');
          logEvent('Träning stoppad.');
        });
      }
    });

    ui.pauseBtn.addEventListener('click', () => {
      if (!agent || !trainingActive) return;
      if (agent.paused) {
        agent.resume();
        ui.pauseBtn.textContent = 'Pausa';
        updateStatus('tränar', 'success');
        logEvent('Träning återupptas.');
      } else {
        agent.pause();
        ui.pauseBtn.textContent = 'Fortsätt';
        updateStatus('pausad');
        logEvent('Träning pausad.');
      }
    });

    ui.stepBtn.addEventListener('click', async () => {
      if (trainingActive) return;
      ensureAgent();
      syncEvalConfig();
      ui.stepBtn.disabled = true;
      updateStatus('beräknar');
      logEvent('Stegar en generation...');
      await agent.stepGeneration(handleSummary);
      updateStatus('idle');
      ui.stepBtn.disabled = false;
    });

    ui.watchBtn.addEventListener('click', () => {
      if (watching) {
        stopWatch();
        return;
      }
      const champion = agent?.bestGenome ?? agent?.population?.bestGenome;
      if (!champion) {
        logEvent('Ingen champion att visa ännu.');
        return;
      }
      startWatch(champion.clone());
    });

    drawEmptyBoard();
    logEvent('Redo. Initiera en ny NEAT-träning för att börja.');
  </script>
</body>
</html>
