<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake-ML ¬∑ Hybrid Max Mode (RL + BFS + Hamilton)</title>
<style>
  :root { --bg:#0b0e14; --panel:#121722; --ink:#e6e6e6; --muted:#a7b0c0; --accent:#4da3ff; --ok:#1ec971; --warn:#ffb703; --err:#ff5370; }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:12px 16px;background:linear-gradient(90deg,#101626,#0b0e14)}
  header h1{margin:0;font-size:16px;font-weight:600}
  main{display:grid;grid-template-columns:340px 1fr;gap:12px;padding:12px}
  @media (max-width:960px){main{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid #1a2333;border-radius:10px;box-shadow:0 0 0 1px #0d1320 inset}
  .pad{padding:12px}
  .controls label{display:block;margin:8px 0 4px;color:var(--muted)}
  .controls input[type=range]{width:100%}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  button{cursor:pointer;border:1px solid #1e2a3f;background:#0f1626;color:#eaeef7;padding:8px 10px;border-radius:8px}
  button.primary{background:var(--accent);color:#001020;border:none}
  button:disabled{opacity:.55;cursor:not-allowed}
  .toggle{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
  .toggle label{display:flex;align-items:center;gap:6px;background:#0e1524;border:1px solid #1b2440;padding:6px 8px;border-radius:8px}
  canvas{display:block;width:100%;height:auto;image-rendering:pixelated;border-radius:10px}
  .stat{display:grid;grid-template-columns:1fr auto;gap:6px 10px}
  .stat div{padding:4px 0;border-bottom:1px dashed #1f2b45}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #253557;background:#0e1524;color:var(--muted);font-size:12px}
  .ok{color:var(--ok)} .warn{color:var(--warn)} .err{color:var(--err)}
  footer{padding:10px 12px;color:#92a1bd}
  .log{max-height:180px;overflow:auto;background:#0c1220;border:1px solid #1a2336;border-radius:8px;padding:8px;font-size:12px;white-space:pre-wrap}
</style>
</head>
<body>
<header>
  <h1>üêç Snake-ML ¬∑ Hybrid Max Mode (RL + BFS + Hamilton)</h1>
</header>

<main>
  <section class="panel pad">
    <div class="controls">
      <div class="row" style="margin-bottom:8px">
        <button id="btnStart" class="primary">Start</button>
        <button id="btnStop">Stop</button>
        <button id="btnReset">Reset</button>
        <span class="pill">Grid: <span id="gridLbl">15√ó15</span></span>
        <span class="pill">Speed: <span id="spdLbl">60 fps</span></span>
      </div>

      <label>Hastighet (frames/sek)</label>
      <input type="range" id="speed" min="5" max="120" step="1" value="60" />

      <label>Œµ (exploration) ‚Äì Max mode s√§tter detta till 0</label>
      <input type="range" id="eps" min="0" max="1" step="0.001" value="0" />

      <div class="toggle">
        <label><input type="checkbox" id="chkHybrid" checked /> Hybrid Controller</label>
        <label><input type="checkbox" id="chkBFS" checked /> BFS-r√§ddning</label>
        <label><input type="checkbox" id="chkHamilton" checked /> Hamilton i slutspel</label>
        <label><input type="checkbox" id="chkLogs" /> Logga h√§ndelser</label>
      </div>

      <div class="row" style="margin-top:8px">
        <button id="btnMax" title="S√§tter Œµ=0, fryser agent och k√∂r hybrid">Max mode</button>
        <button id="btnRLonly" title="Inaktiverar BFS/Hamilton">RL only</button>
        <button id="btnSafe" title="BFS+Hamilton utan RL">Safe mode</button>
      </div>

      <h3 style="margin:14px 0 6px">Ladda tr√§nad RL-modell</h3>
      <div class="row" style="align-items:stretch">
        <input type="file" id="modelFile" accept=".json,application/json" style="flex:1;min-width:140px" />
        <button id="btnLoadModel">Ladda</button>
        <span id="modelStatus" class="pill" style="white-space:nowrap">Ingen modell</span>
      </div>
      <p style="margin:4px 0 0;font-size:12px;color:var(--muted)">
        V√§lj en <code>checkpoint.json</code> fr√•n <code>train.js</code> (version&nbsp;5). Q-n√§tet anv√§nds direkt som RL-agent.
      </p>
    </div>

    <h3 style="margin-top:12px">Statistik</h3>
    <div class="stat mono" id="stats"></div>

    <h3 style="margin-top:12px">Logg</h3>
    <div class="log mono" id="log"></div>
  </section>

  <section class="panel pad">
    <canvas id="board" width="600" height="600"></canvas>
  </section>
</main>

<footer class="panel pad">
  Tips: K√∂r <b>Max mode</b> (Œµ=0) och l√•t RL ‚Üí BFS ‚Üí Hamilton ta dig ‚Äúhela v√§gen‚Äù.<br/>
  Vill du k√∂ra din tr√§nade agent? Ladda <code>checkpoint.json</code> under ‚ÄùLadda tr√§nad RL-modell‚Äù eller s√§tt manuellt <code>window.rlAgent = { chooseAction(state){ ‚Ä¶ } }</code>.
</footer>

<script>
///////////////////////////////////////////////
// Utils
///////////////////////////////////////////////
const DIRS = { UP:{x:0,y:-1}, DOWN:{x:0,y:1}, LEFT:{x:-1,y:0}, RIGHT:{x:1,y:0} };
const DIR_KEYS = ["UP","DOWN","LEFT","RIGHT"];
function samePos(a,b){ return a.x===b.x && a.y===b.y; }
function inside(x,y,cols,rows){ return x>=0 && y>=0 && x<cols && y<rows; }
function manhattan(a,b){ return Math.abs(a.x-b.x)+Math.abs(a.y-b.y); }

///////////////////////////////////////////////
// Snake Environment (single-file, no deps)
///////////////////////////////////////////////
class SnakeEnv{
  constructor(cols=15, rows=15){
    this.cols=cols|0; this.rows=rows|0;
    this._visitDecay = 0.995;
    this._visitIncrement = 0.3;
    this.reset();
  }
  _key(x,y){ return `${x},${y}`; }
  _idx(x,y){ return y*this.cols + x; }
  _ensureVisit(){
    const size = this.cols*this.rows;
    if(!this.visit || this.visit.length!==size){
      this.visit = new Float32Array(size);
    }else{
      this.visit.fill(0);
    }
  }
  reset(){
    this.alive = true;
    this.deathReason = null;
    this.steps = 0;
    this.fruits = 0;
    this.totalReward = 0;
    this.stepsSinceFruit = 0;
    this.loopWindow = [];
    const cx = (this.cols/2|0), cy=(this.rows/2|0);
    this.dir = "RIGHT";
    this.snake = [{x:cx,y:cy},{x:cx-1,y:cy},{x:cx-2,y:cy}];
    this.snakeSet = new Set(this.snake.map(seg=>this._key(seg.x,seg.y)));
    this._ensureVisit();
    this.placeFruit();
    return this.getState();
  }
  placeFruit(){
    const free=[];
    const occ = this.snakeSet || new Set(this.snake.map(p=>this._key(p.x,p.y)));
    for(let y=0;y<this.rows;y++){
      for(let x=0;x<this.cols;x++){
        const k=this._key(x,y);
        if(!occ.has(k)) free.push({x,y});
      }
    }
    this.fruit = free.length? free[(Math.random()*free.length)|0] : {x:0,y:0};
  }
  opposite(a,b){
    return (a==="UP"&&b==="DOWN")||(a==="DOWN"&&b==="UP")||(a==="LEFT"&&b==="RIGHT")||(a==="RIGHT"&&b==="LEFT");
  }
  getVisit(x,y){
    if(x<0||y<0||x>=this.cols||y>=this.rows) return 1;
    return this.visit ? this.visit[this._idx(x,y)]||0 : 0;
  }
  _dirVec(){ return DIRS[this.dir] || DIRS.RIGHT; }
  _computeRLState(){
    const head=this.snake[0];
    const dirVec=this._dirVec();
    const left={x:-dirVec.y,y:dirVec.x};
    const right={x:dirVec.y,y:-dirVec.x};
    const block=(dx,dy)=>{
      const x=head.x+dx, y=head.y+dy;
      if(!inside(x,y,this.cols,this.rows)) return 1;
      return this.snakeSet && this.snakeSet.has(this._key(x,y)) ? 1 : 0;
    };
    const danger=[block(dirVec.x,dirVec.y),block(left.x,left.y),block(right.x,right.y)];
    const dir=[dirVec.y===-1?1:0, dirVec.y===1?1:0, dirVec.x===-1?1:0, dirVec.x===1?1:0];
    const fruit=[
      this.fruit.y<head.y?1:0,
      this.fruit.y>head.y?1:0,
      this.fruit.x<head.x?1:0,
      this.fruit.x>head.x?1:0
    ];
    const denomY=Math.max(1,this.rows-1);
    const denomX=Math.max(1,this.cols-1);
    const dists=[head.y/denomY,(this.rows-1-head.y)/denomY,head.x/denomX,(this.cols-1-head.x)/denomX];
    const dx=this.fruit.x-head.x;
    const dy=this.fruit.y-head.y;
    const len=Math.hypot(dx,dy)||1;
    const crowd=[
      this.getVisit(head.x,head.y-1),
      this.getVisit(head.x,head.y+1),
      this.getVisit(head.x-1,head.y),
      this.getVisit(head.x+1,head.y)
    ];
    return Float32Array.from([
      ...danger,
      ...dir,
      ...fruit,
      ...dists,
      dy/len,
      dx/len,
      ...crowd
    ]);
  }
  getState(){
    const head=this.snake[0];
    const dx = this.fruit.x-head.x;
    const dy = this.fruit.y-head.y;
    const nearWall = {
      up: head.y===0, down: head.y===this.rows-1,
      left: head.x===0, right: head.x===this.cols-1
    };
    return {
      cols:this.cols, rows:this.rows,
      head, fruit:this.fruit, dir:this.dir,
      snake:this.snake.slice(), // copy for safety
      len:this.snake.length,
      dx, dy, nearWall,
      steps:this.steps, fruits:this.fruits,
      stepsSinceFruit:this.stepsSinceFruit,
      rlState:this._computeRLState(),
    };
  }
  step(action){
    if(!this.alive) return {done:true, reason:this.deathReason, reward:0, state:this.getState()};
    // Stoppa 180¬∞-v√§ndning
    if(this.opposite(this.dir, action)) action=this.dir;

    const dirVec = DIRS[action]||DIRS[this.dir];
    this.dir = action;
    const head = this.snake[0];
    const nx = head.x + dirVec.x;
    const ny = head.y + dirVec.y;

    // V√§ggkrasch?
    if(!inside(nx,ny,this.cols,this.rows)){
      this.alive=false; this.deathReason="WALL";
      return {done:true, reason:"WALL", reward:-5, state:this.getState()};
    }

    const nextIsFruit = (nx===this.fruit.x && ny===this.fruit.y);

    // Klassisk Snake-fix: r√§kna inte svansens sista ruta som kollision om den flyttas bort i detta steg
    const bodyToCheck = nextIsFruit ? this.snake : this.snake.slice(0,-1);
    const hitsBody = bodyToCheck.some(seg=>seg.x===nx && seg.y===ny);
    if(hitsBody){
      this.alive=false; this.deathReason="SELF";
      return {done:true, reason:"SELF", reward:-4, state:this.getState()};
    }

    if(this.visit){
      for(let i=0;i<this.visit.length;i++) this.visit[i]*=this._visitDecay;
    }

    const newHead = {x:nx,y:ny};
    this.snake.unshift(newHead);
    if(!this.snakeSet) this.snakeSet = new Set();
    this.snakeSet.add(this._key(nx,ny));
    let reward = -0.01; // liten stepp-kostnad
    if(nextIsFruit){
      this.fruits++;
      this.stepsSinceFruit=0;
      reward += 2.0;
      this.placeFruit();
    }else{
      const tail = this.snake.pop();
      if(tail) this.snakeSet.delete(this._key(tail.x,tail.y));
      this.stepsSinceFruit++;
      if(this.visit){
        const idx = this._idx(nx,ny);
        this.visit[idx] = Math.min(1, (this.visit[idx]||0) + this._visitIncrement);
      }
    }

    this.steps++;
    this.totalReward += reward;

    // Loopdetektor (spara senaste 16 huvudpositioner)
    const key=this._key(nx,ny);
    this.loopWindow.push(key);
    if(this.loopWindow.length>16) this.loopWindow.shift();

    return {done:false, reward, state:this.getState()};
  }
}

///////////////////////////////////////////////
// BFS (kortaste v√§g till frukt)
///////////////////////////////////////////////
function bfsPath(env){
  const {cols,rows,snake,fruit} = env.getState();
  const head = snake[0];
  // Blockera kroppen, men till√•t att g√• in i svansens *sista* cell (den r√∂r sig bort om vi inte √§ter)
  const bodySet = new Set(snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
  const q=[head];
  const prev = new Map();
  const seen = new Set([`${head.x},${head.y}`]);

  while(q.length){
    const cur=q.shift();
    if(cur.x===fruit.x && cur.y===fruit.y){
      // Rekonstruera stig
      const path=[cur];
      let k=`${cur.x},${cur.y}`;
      while(prev.has(k)){ const p=prev.get(k); path.push(p); k=`${p.x},${p.y}`; }
      path.reverse();
      return path;
    }
    for(const d of DIR_KEYS){
      const v=DIRS[d];
      const nx=cur.x+v.x, ny=cur.y+v.y;
      if(!inside(nx,ny,cols,rows)) continue;
      const nk=`${nx},${ny}`;
      if(seen.has(nk)) continue;
      if(bodySet.has(nk)) continue;
      seen.add(nk);
      prev.set(nk,cur);
      q.push({x:nx,y:ny});
    }
  }
  return null; // ingen v√§g
}

///////////////////////////////////////////////
// Hamilton: serpentin-g√•ng + ‚Äúpath order‚Äù strategi
// Obs: riktig Hamilton-CYKEL kr√§ver j√§mn dimension. F√∂r 15√ó15 k√∂r vi path+wrap-logik med fallback BFS.
///////////////////////////////////////////////
function generateSerpentineOrder(cols,rows){
  // Returnerar en lista av celler i ‚Äúlawnmower‚Äù-ordning
  const order=[];
  for(let y=0;y<rows;y++){
    if(y%2===0){
      for(let x=0;x<cols;x++) order.push({x,y});
    }else{
      for(let x=cols-1;x>=0;x--) order.push({x,y});
    }
  }
  // Map fr√•n ‚Äúx,y‚Äù -> index
  const idx=new Map(order.map((p,i)=>[`${p.x},${p.y}`,i]));
  return {order, idx};
}
function nextOnSerpentine(env, serp){
  const {head} = env.getState();
  const k=`${head.x},${head.y}`;
  const i = serp.idx.get(k);
  if(i===undefined) return null;
  const next = serp.order[(i+1) % serp.order.length];
  return next;
}
function dirToAction(from,to){
  if(!to||!from) return "RIGHT";
  if(to.x>from.x) return "RIGHT";
  if(to.x<from.x) return "LEFT";
  if(to.y>from.y) return "DOWN";
  return "UP";
}

///////////////////////////////////////////////
// RL-checkpoint ‚Üí agent (frontend inference)
///////////////////////////////////////////////
function decodeTensor(entry){
  if(!entry || typeof entry.data!=="string" || !Array.isArray(entry.shape)){
    throw new Error("Ogiltig viktpost i checkpoint");
  }
  const raw = atob(entry.data);
  const bytes = new Uint8Array(raw.length);
  for(let i=0;i<raw.length;i++) bytes[i]=raw.charCodeAt(i);
  const length = entry.shape.reduce((a,b)=>a*b,1);
  const dtype = entry.dtype || "float32";
  let data;
  if(dtype==="float32"){
    data = new Float32Array(bytes.buffer, 0, length);
  }else if(dtype==="int32"){
    const ints = new Int32Array(bytes.buffer, 0, length);
    data = new Float32Array(length);
    for(let i=0;i<length;i++) data[i]=ints[i];
  }else{
    throw new Error(`St√∂der inte dtype ${dtype}`);
  }
  return { shape: entry.shape.slice(), data };
}

class LoadedModelAgent{
  constructor(opts={}){
    this.name = opts.name ?? "CheckpointAgent";
    this.meta = opts.meta ?? null;
    this.loaded = false;
    this.dueling = true;
    this.network = null;
  }

  loadFromState(state){
    if(!state || !Array.isArray(state.weights)) throw new Error("Saknar viktdata i checkpoint");
    if(state.stateDim===undefined || state.actionDim===undefined){
      throw new Error("Checkpoint saknar dimensionsdata");
    }
    const version = state.version ?? 0;
    if(version && version < 5){
      throw new Error(`Checkpoint-version ${version} st√∂ds inte (kr√§ver ‚â•5)`);
    }
    this.stateDim = state.stateDim;
    this.actionDim = state.actionDim;
    const cfg = state.config ?? {};
    this.dueling = cfg.dueling !== false;
    this.layers = Array.isArray(cfg.layers) && cfg.layers.length ? cfg.layers.slice() : [256,256,128];
    const weights = state.weights.map(decodeTensor);
    let cursor = 0;
    const trunk=[];
    for(const units of this.layers){
      const kernel = weights[cursor++];
      const bias = weights[cursor++];
      if(!kernel || !bias) throw new Error("Ofullst√§ndig viktdata (trunk)");
      trunk.push({ kernel, bias, activation:"relu" });
    }
    if(this.dueling){
      const advHidden = { kernel: weights[cursor++], bias: weights[cursor++], activation:"relu" };
      const advOut = { kernel: weights[cursor++], bias: weights[cursor++], activation:"linear" };
      const valHidden = { kernel: weights[cursor++], bias: weights[cursor++], activation:"relu" };
      const valOut = { kernel: weights[cursor++], bias: weights[cursor++], activation:"linear" };
      if([advHidden,advOut,valHidden,valOut].some(layer=>!layer.kernel || !layer.bias)){
        throw new Error("Ofullst√§ndig viktdata (dueling)");
      }
      this.network = { trunk, advantage:{ hidden:advHidden, output:advOut }, value:{ hidden:valHidden, output:valOut } };
    }else{
      const output = { kernel: weights[cursor++], bias: weights[cursor++], activation:"linear" };
      if(!output.kernel || !output.bias) throw new Error("Ofullst√§ndig viktdata (output)");
      this.network = { trunk, output };
    }
    if(cursor !== weights.length){
      console.warn("[MODEL] √ñverfl√∂diga vikter i checkpoint, ignorerar", weights.length - cursor);
    }
    this.loaded = true;
    return this;
  }

  _dense(input, layer){
    const { kernel, bias, activation } = layer;
    const [inDim, outDim] = kernel.shape;
    const out = new Float32Array(outDim);
    const weights = kernel.data;
    const biasData = bias?.data;
    for(let o=0;o<outDim;o++){
      let sum = biasData ? biasData[o] : 0;
      for(let i=0;i<inDim;i++){
        sum += input[i] * weights[i*outDim + o];
      }
      if(activation === "relu") sum = sum > 0 ? sum : 0;
      out[o] = sum;
    }
    return out;
  }

  _forward(obs){
    let x = obs;
    for(const layer of this.network.trunk){
      x = this._dense(x, layer);
    }
    if(this.dueling){
      const advHidden = this._dense(x, this.network.advantage.hidden);
      const adv = this._dense(advHidden, this.network.advantage.output);
      const valHidden = this._dense(x, this.network.value.hidden);
      const val = this._dense(valHidden, this.network.value.output);
      const out = new Float32Array(this.actionDim);
      const base = val[0] ?? 0;
      for(let i=0;i<out.length;i++) out[i] = adv[i] + base;
      return out;
    }
    return this._dense(x, this.network.output);
  }

  _turn(currentDir, actionIdx){
    const order = ["UP","RIGHT","DOWN","LEFT"];
    let idx = order.indexOf(currentDir);
    if(idx===-1) idx = 1; // default RIGHT
    if(this.actionDim === 3){
      if(actionIdx === 1) return order[(idx + 3) % 4];
      if(actionIdx === 2) return order[(idx + 1) % 4];
      return order[idx];
    }
    return order[actionIdx % order.length];
  }

  chooseAction(state){
    if(!this.loaded) throw new Error("Ingen modell laddad");
    const obs = state.rlState instanceof Float32Array ? state.rlState : Float32Array.from(state.rlState ?? []);
    if(obs.length !== this.stateDim){
      throw new Error(`Felaktig observationsdim (${obs.length} ‚â† ${this.stateDim})`);
    }
    const q = this._forward(obs);
    let best = 0;
    for(let i=1;i<q.length;i++) if(q[i] > q[best]) best = i;
    return this._turn(state.dir, best);
  }
}

function parseCheckpointPayload(payload){
  const data = typeof payload === "string" ? JSON.parse(payload) : payload;
  if(!data || typeof data !== "object") throw new Error("Ogiltigt checkpoint-format");
  const agentState = data.agent ?? data;
  const agent = new LoadedModelAgent({ name: agentState.kind ?? "RL-agent", meta: data.meta ?? null });
  agent.loadFromState(agentState);
  return { agent, meta: data.meta ?? null, rewardConfig: data.rewardConfig ?? null };
}

window.LoadedModelAgent = LoadedModelAgent;
window.parseCheckpointPayload = parseCheckpointPayload;

///////////////////////////////////////////////
//
// RL-agent (stub) ‚Äî BYT till din tr√§nade agent h√§r:
// S√§tt window.rlAgent = { chooseAction(state){ ... } } f√∂re start.
//
///////////////////////////////////////////////
const defaultRLAgent = {
  // Enkel heuristik: g√• mot frukten, f√∂rs√∂k undvika v√§ggar/180¬∞, fallback till s√§kra moves
  chooseAction(state){
    const {head,fruit,cols,rows,dir} = state;
    const prefs=[];
    if(fruit.x>head.x) prefs.push("RIGHT");
    if(fruit.x<head.x) prefs.push("LEFT");
    if(fruit.y>head.y) prefs.push("DOWN");
    if(fruit.y<head.y) prefs.push("UP");
    for(const d of DIR_KEYS) if(!prefs.includes(d)) prefs.push(d);

    const opposite = {UP:"DOWN",DOWN:"UP",LEFT:"RIGHT",RIGHT:"LEFT"}[dir];
    const snakeSet = new Set(state.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
    for(const a of prefs){
      if(a===opposite) continue;
      const v=DIRS[a];
      const nx=head.x+v.x, ny=head.y+v.y;
      if(!inside(nx,ny,cols,rows)) continue;
      if(snakeSet.has(`${nx},${ny}`)) continue;
      return a;
    }
    return dir;
  }
};

if(typeof window.rlAgent!=="object" || typeof window.rlAgent.chooseAction!=="function"){
  window.rlAgent = defaultRLAgent;
}

///////////////////////////////////////////////
// Hybrid Controller
///////////////////////////////////////////////
class HybridController{
  constructor(env, opts={}){
    this.env = env;
    this.epsilon = 0; // s√§tts via UI
    this.enableHybrid = true;
    this.enableBFS = true;
    this.enableHamilton = true;
    this.bfsStuckSteps = opts.bfsStuckSteps ?? 80;
    this.loopRepeatThreshold = opts.loopRepeatThreshold ?? 3;
    this.hamiltonFillRatio = opts.hamiltonFillRatio ?? 0.80;
    this.mode = "hybrid"; // "hybrid" | "rl" | "safe"
    this._serp = generateSerpentineOrder(env.cols, env.rows);
  }
  setMode(m){
    this.mode=m;
  }
  setFlags({hybrid,bfs,hamilton}){
    if(hybrid!==undefined) this.enableHybrid=!!hybrid;
    if(bfs!==undefined) this.enableBFS=!!bfs;
    if(hamilton!==undefined) this.enableHamilton=!!hamilton;
  }
  setEpsilon(e){ this.epsilon=Math.max(0,Math.min(1, +e || 0)); }
  _log(msg){ if(ui.chkLogs.checked) appendLog(msg); }

  chooseAction(){
    const s = this.env.getState();

    // Safe mode: ignorera RL helt, anv√§nd BFS/Hamilton
    if(this.mode==="safe"){
      const a = this._hamiltonOrBFS(s);
      if(a) return a;
      return this._fallbackRL(s);
    }

    // RL only: ren agent (men respektera epsilon)
    if(this.mode==="rl"){
      return this._rlEpsGreedy(s);
    }

    // Hybrid:
    // 1) Hamilton i slutspel
    const fill = s.len/(s.cols*s.rows);
    if(this.enableHamilton && fill >= this.hamiltonFillRatio){
      const a = this._hamiltonStep(s);
      if(a){ this._log(`Hamilton step (fill ${(fill*100).toFixed(1)}%)`); return a; }
    }

    // 2) BFS vid fastna/loop
    const loops = this._estimateLoopCount();
    if(this.enableBFS && (s.stepsSinceFruit >= this.bfsStuckSteps || loops>=this.loopRepeatThreshold)){
      const a = this._bfsStep(s);
      if(a){ this._log(`BFS rescue (sinceFruit=${s.stepsSinceFruit}, loops=${loops})`); return a; }
    }

    // 3) RL standard
    return this._rlEpsGreedy(s);
  }

  _rlEpsGreedy(s){
    if(Math.random() < this.epsilon){
      // slumpat lagligt drag
      const legal=[];
      for(const a of DIR_KEYS){
        if(this.env.opposite(s.dir,a)) continue;
        const v=DIRS[a], nx=s.head.x+v.x, ny=s.head.y+v.y;
        if(!inside(nx,ny,s.cols,s.rows)) continue;
        const bodySet=new Set(s.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
        if(bodySet.has(`${nx},${ny}`)) continue;
        legal.push(a);
      }
      if(legal.length) return legal[(Math.random()*legal.length)|0];
    }
    return window.rlAgent.chooseAction(s);
  }

  _bfsStep(s){
    const path = bfsPath(this.env);
    if(path && path.length>1){
      const next = path[1];
      return dirToAction(s.head,next);
    }
    return null;
  }

  _hamiltonStep(s){
    if(!this._serp) this._serp = generateSerpentineOrder(s.cols,s.rows);
    const next = nextOnSerpentine(this.env, this._serp);
    if(!next) return null;

    // Om n√§sta serpentin-cell √§r upptagen av kroppen (f√∂rutom svansens sista),
    // prova BFS som ‚Äútail-chase‚Äù fallback ‚Äì annars k√∂r RL.
    const bodySet=new Set(s.snake.slice(0,-1).map(p=>`${p.x},${p.y}`));
    if(bodySet.has(`${next.x},${next.y}`)){
      const path=bfsPath(this.env);
      if(path && path.length>1) return dirToAction(s.head, path[1]);
      return null;
    }
    return dirToAction(s.head,next);
  }

  _hamiltonOrBFS(s){
    const aH = this._hamiltonStep(s);
    if(aH) return aH;
    const aB = this._bfsStep(s);
    if(aB) return aB;
    return null;
  }

  _fallbackRL(s){ return window.rlAgent.chooseAction(s); }

  _estimateLoopCount(){
    // grov loopindikator: antal duplicerade huvudpositioner i f√∂nster
    const arr = this.env.loopWindow;
    if(arr.length<8) return 0;
    const seen=new Map();
    for(const k of arr) seen.set(k,(seen.get(k)||0)+1);
    let repeats=0;
    for(const v of seen.values()) if(v>1) repeats++;
    return repeats; // 0..n
  }
}

///////////////////////////////////////////////
// Rendering
///////////////////////////////////////////////
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');

function draw(env){
  const {cols,rows,snake,fruit} = env.getState();
  const cw = canvas.width, ch=canvas.height;
  const cs = Math.floor(Math.min(cw/cols, ch/rows));

  // bakgrund
  ctx.fillStyle = "#0b0e14";
  ctx.fillRect(0,0,cw,ch);

  // grid-rutor
  for(let y=0;y<rows;y++){
    for(let x=0;x<cols;x++){
      const px=x*cs, py=y*cs;
      ctx.fillStyle = (x+y)%2===0 ? "#111827" : "#0f172a";
      ctx.fillRect(px,py,cs,cs);
    }
  }

  // frukt
  ctx.fillStyle = "#ff5370";
  ctx.fillRect(fruit.x*cs+1, fruit.y*cs+1, cs-2, cs-2);

  // snake
  for(let i=snake.length-1;i>=0;i--){
    const s = snake[i];
    const px=s.x*cs, py=s.y*cs;
    ctx.fillStyle = i===0 ? "#4da3ff" : "#1ec971";
    ctx.fillRect(px+1,py+1,cs-2,cs-2);
  }
}

///////////////////////////////////////////////
// UI + loop
///////////////////////////////////////////////
const ui = {
  btnStart: document.getElementById('btnStart'),
  btnStop: document.getElementById('btnStop'),
  btnReset: document.getElementById('btnReset'),
  btnMax: document.getElementById('btnMax'),
  btnRLonly: document.getElementById('btnRLonly'),
  btnSafe: document.getElementById('btnSafe'),
  btnLoadModel: document.getElementById('btnLoadModel'),
  modelFile: document.getElementById('modelFile'),
  modelStatus: document.getElementById('modelStatus'),
  speed: document.getElementById('speed'),
  eps: document.getElementById('eps'),
  chkHybrid: document.getElementById('chkHybrid'),
  chkBFS: document.getElementById('chkBFS'),
  chkHamilton: document.getElementById('chkHamilton'),
  chkLogs: document.getElementById('chkLogs'),
  stats: document.getElementById('stats'),
  log: document.getElementById('log'),
  spdLbl: document.getElementById('spdLbl'),
  gridLbl: document.getElementById('gridLbl')
};
function setModelStatus(text, tone){
  ui.modelStatus.textContent = text;
  ui.modelStatus.classList.remove('ok','err','warn');
  if(tone) ui.modelStatus.classList.add(tone);
}
function appendLog(msg){
  const t = new Date().toLocaleTimeString();
  ui.log.textContent += `[${t}] ${msg}\n`;
  ui.log.scrollTop = ui.log.scrollHeight;
}
setModelStatus('Ingen modell','warn');
function setStats(){
  const s = env.getState();
  const fill = (s.len/(s.cols*s.rows))*100;
  ui.stats.innerHTML = `
    <div>Steg</div><div>${s.steps}</div>
    <div>Frukt</div><div>${s.fruits}</div>
    <div>L√§ngd</div><div>${s.len}</div>
    <div>Steps sedan frukt</div><div>${s.stepsSinceFruit}</div>
    <div>Fyllnadsgrad</div><div>${fill.toFixed(1)}%</div>
  `;
}

let env = new SnakeEnv(15,15);
let ctrl = new HybridController(env, { bfsStuckSteps:80, loopRepeatThreshold:3, hamiltonFillRatio:0.80 });
ui.gridLbl.textContent = `${env.cols}√ó${env.rows}`;

let running=false, rafId=null, acc=0, fps=+ui.speed.value;
ui.spdLbl.textContent = `${fps} fps`;

async function loadSelectedModel(){
  const file = ui.modelFile.files && ui.modelFile.files[0];
  if(!file){
    setModelStatus('Ingen fil vald','warn');
    return;
  }
  setModelStatus('Laddar‚Ä¶','warn');
  ui.btnLoadModel.disabled = true;
  try{
    const text = await file.text();
    const { agent, meta } = parseCheckpointPayload(text);
    agent.meta = meta;
    agent.name = file.name;
    window.rlAgent = agent;
    const details=[];
    if(meta?.episode) details.push(`episod ${meta.episode}`);
    if(meta?.boardSize) details.push(`${meta.boardSize}√ó${meta.boardSize}`);
    const status = details.length ? `Laddad: ${details.join(', ')}` : 'Modell laddad';
    setModelStatus(status,'ok');
    appendLog(`‚úÖ Modell laddad: ${file.name}${details.length?` (${details.join(', ')})`:''}`);
    env.reset();
    draw(env);
    setStats();
  }catch(err){
    console.error('[MODEL]', err);
    const msg = err?.message ?? String(err);
    setModelStatus(`Fel: ${msg}`,'err');
    appendLog(`‚ùå Modellfel: ${msg}`);
  }finally{
    ui.btnLoadModel.disabled = false;
  }
}

function tick(dt){
  if(!running) return;
  acc += dt;
  const frameTime = 1000/fps;
  while(acc>=frameTime){
    acc -= frameTime;
    stepOnce();
  }
  draw(env);
  setStats();
  rafId = requestAnimationFrame(loop);
}
function loop(ts){
  if(!loop.last) loop.last = ts;
  const dt = ts - loop.last; loop.last = ts;
  tick(dt);
}
function stepOnce(){
  if(!env.alive){
    // auto-reset n√§sta episod
    const reason=env.deathReason;
    if(reason) appendLog(`üí• Krasch: ${reason}`);
    env.reset();
    return;
  }
  const action = ctrl.enableHybrid ? ctrl.chooseAction() : window.rlAgent.chooseAction(env.getState());
  const res = env.step(action);
  if(res.done){
    appendLog(`üí• Episode slut: ${res.reason||"d√∂d"}`);
  }
}

///////////////////////////////////////////////
// Event handlers
///////////////////////////////////////////////
ui.modelFile.addEventListener('change', ()=>{
  const file = ui.modelFile.files && ui.modelFile.files[0];
  if(file){
    setModelStatus(`Vald: ${file.name}`);
  }else{
    setModelStatus('Ingen modell','warn');
  }
});
ui.btnLoadModel.onclick=()=>{
  loadSelectedModel();
};
ui.btnStart.onclick=()=>{
  if(running) return;
  running=true; loop.last=undefined;
  appendLog('‚ñ∂Ô∏è Start');
  rafId=requestAnimationFrame(loop);
};
ui.btnStop.onclick=()=>{
  running=false; if(rafId) cancelAnimationFrame(rafId);
  appendLog('‚è∏Ô∏è Stop');
};
ui.btnReset.onclick=()=>{
  env.reset(); draw(env); setStats(); appendLog('üîÑ Reset');
};

ui.speed.oninput=()=>{
  fps=+ui.speed.value||60;
  ui.spdLbl.textContent=`${fps} fps`;
};
ui.eps.oninput=()=>{
  ctrl.setEpsilon(+ui.eps.value||0);
};

ui.chkHybrid.onchange=()=>{ ctrl.enableHybrid=ui.chkHybrid.checked; };
ui.chkBFS.onchange=()=>{ ctrl.enableBFS=ui.chkBFS.checked; };
ui.chkHamilton.onchange=()=>{ ctrl.enableHamilton=ui.chkHamilton.checked; };

ui.btnMax.onclick=()=>{
  ui.eps.value = "0";
  ctrl.setEpsilon(0);
  ctrl.setFlags({hybrid:true,bfs:true,hamilton:true});
  ctrl.setMode("hybrid");
  ui.chkHybrid.checked=true; ui.chkBFS.checked=true; ui.chkHamilton.checked=true;
  appendLog('üèÅ Max mode: Œµ=0, Hybrid+BFS+Hamilton aktiva');
};
ui.btnRLonly.onclick=()=>{
  ctrl.setMode("rl");
  ctrl.setFlags({hybrid:false}); // praktiskt: kryssruta p√•verkar inte "mode", men vi visar √§nd√•
  ui.chkHybrid.checked=false;
  appendLog('ü§ñ RL only (inga BFS/Hamilton-ingrepp)');
};
ui.btnSafe.onclick=()=>{
  ctrl.setMode("safe");
  ctrl.setFlags({hybrid:true,bfs:true,hamilton:true});
  ui.chkHybrid.checked=true; ui.chkBFS.checked=true; ui.chkHamilton.checked=true;
  ui.eps.value="0"; ctrl.setEpsilon(0);
  appendLog('üõü Safe mode: BFS+Hamilton, ingen RL (Œµ=0)');
};

// Startl√§ge: rita stillbild
draw(env); setStats();
</script>
</body>
</html>
