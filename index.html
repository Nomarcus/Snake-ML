
<!DOCTYPE html>
<html lang="sv">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Snake — Deep Q-Learning (dueling double + anti-loop)</title>
<script defer src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<style>
/* ... (oförändrad CSS från din version) ... */
:root {--bg:#0f1220;--panel:#151936;--ink:#e7eaf6;--muted:#9aa3c7;--a:#6c7bff;--b:#9b5cff}
*{box-sizing:border-box}body{margin:0;background:radial-gradient(1200px 600px at 20% -10%,#1a2050 0%,#101326 40%,#0b0e1c 100%);color:var(--ink);font:14px/1.5 system-ui,Segoe UI,Inter,Roboto,sans-serif}
header{padding:16px 24px;display:flex;align-items:center;gap:14px;position:sticky;top:0;z-index:10;background:rgba(10,13,24,.6);backdrop-filter:blur(10px);border-bottom:1px solid #1b1f3a}
.logo{font-weight:900;font-size:18px;background:linear-gradient(135deg,var(--a),var(--b));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
main{max-width:1200px;margin:24px auto;padding:0 16px;display:grid;grid-template-columns:520px 1fr;gap:16px}
.card{background:var(--panel);border:1px solid #1b1f3a;border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
h2{margin:0 0 10px;font-size:16px;color:#dfe3ff}
canvas#board{width:500px;height:500px;image-rendering:pixelated;border-radius:12px;background:#0f1328;border:1px solid #1b1f3a}
.row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
button{appearance:none;border:none;padding:10px 14px;border-radius:10px;color:#fff;background:linear-gradient(135deg,var(--a),var(--b));font-weight:700;cursor:pointer;transition:.2s transform,.2s box-shadow;box-shadow:0 6px 20px rgba(108,123,255,.35)}
button:hover{transform:translateY(-1px)}
button.secondary{background:#23284f;box-shadow:none;color:#cfd6ff;border:1px solid #2a2f61}
button.danger{background:linear-gradient(135deg,#ff6b6b,#ff3d77)}
label{color:var(--muted);font-size:12px}
input[type="range"]{width:220px}
.kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
.kpi .item{background:#111533;padding:12px;border-radius:12px;border:1px solid #1b1f3a}
.kpi .item b{display:block;font-size:12px;color:#9aa3c7;font-weight:600}
.kpi .item span{font-weight:900;font-size:18px}
.split{display:grid;grid-template-columns:1fr 1fr;gap:10px}
canvas.chart{width:100%;height:140px;background:#0b1030;border-radius:10px;border:1px solid #1b1f3a}
.mono{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;color:#c7d2fe}
.badge{padding:2px 8px;border-radius:999px;border:1px solid #2a2f61;background:#1a1f46;color:#cfd6ff;font-size:12px}
.hint{color:#9aa3c7;font-size:12px}
.hidden{display:none!important}
.tabs{margin-left:auto;display:flex;gap:10px;align-items:center}
.tabs button{appearance:none;border:1px solid #2a2f61;padding:8px 14px;border-radius:999px;background:transparent;color:#b5bce0;font-weight:600;cursor:pointer;box-shadow:none;transition:.2s background,.2s color}
.tabs button.active{background:linear-gradient(135deg,var(--a),var(--b));color:#fff;border-color:transparent}
.tabs button:hover{transform:none;background:#1c2148;color:#fff}
.tabs button:focus-visible{outline:2px solid var(--a);outline-offset:2px}
#guideView{max-width:900px;margin:24px auto;padding:0 16px;display:flex;flex-direction:column;gap:16px}
#guideView .card{padding:24px}
#guideView h2{font-size:20px;margin-bottom:12px}
#guideView h3{margin-top:20px;margin-bottom:8px;color:#dfe3ff}
#guideView p,#guideView li{color:#c7cdef}
#guideView dl{margin:0;display:grid;grid-template-columns:160px 1fr;gap:10px 18px}
#guideView dt{font-weight:700;color:#dfe3ff}
#guideView dd{margin:0;color:#c7cdef;font-size:13px;line-height:1.6}
#guideView ul{padding-left:18px;margin:8px 0}
#guideView ol{padding-left:20px;margin:8px 0}
#guideView .muted{color:#9aa3c7;font-size:12px;margin-top:12px}
@media(max-width:700px){#guideView dl{grid-template-columns:1fr}#guideView dt{margin-top:12px}}
footer{opacity:.7;text-align:center;padding:18px}
@media(max-width:1050px){main{grid-template-columns:1fr}canvas#board{width:100%;height:auto}}
</style>
</head>
<body>
<header>
  <div class="logo">Snake • Deep Q-Learning</div>
  <span class="badge" id="trainState">idle</span>
  <span class="badge">ε <span id="epsReadout">1.00</span></span>
  <span class="badge">γ <span id="gammaReadout">0.98</span></span>
  <span class="badge">LR <span id="lrReadout">0.0005</span></span>
  <nav class="tabs">
    <button type="button" id="tabTraining" class="active">Träning</button>
    <button type="button" id="tabGuide">Guide</button>
  </nav>
</header>

<main id="trainingView">
  <div class="card">
    <h2>Game</h2>
    <canvas id="board" width="500" height="500"></canvas>

    <div class="row" style="margin-top:10px">
      <button id="btnTrain">▶ Train</button>
      <button id="btnPause" class="secondary">Pause</button>
      <button id="btnStep" class="secondary">Step 1 ep</button>
      <button id="btnWatch" class="secondary">Watch Smooth</button>
      <button id="btnReset" class="secondary">Reset Env</button>
      <button id="btnSave" class="secondary">Save</button>
      <button id="btnLoad" class="secondary">Load</button>
      <button id="btnClear" class="danger">Clear Saved</button>
    </div>

    <div class="row" style="margin-top:6px">
      <label>Cells:
        <input type="range" id="gridSize" min="10" max="30" step="2" value="20">
        <span class="mono" id="gridLabel">20×20</span>
      </label>
      <label>Render every:
        <input type="range" id="renderEvery" min="1" max="200" step="1" value="1">
        <span class="mono" id="renderLabel">1 step</span>
      </label>
      <label>FPS limit:
        <input type="range" id="fpsLimit" min="10" max="240" step="10" value="180">
        <span class="mono" id="fpsLabel">180</span>
      </label>
    </div>
    <p class="hint">Lägre “Render every” eller högre “FPS limit” = mjukare. Träningen skalar upp brädet automatiskt med bra resultat.</p>
  </div>

  <div class="card">
    <h2>Training Stats</h2>
    <div class="kpi">
      <div class="item"><b>Episodes</b><span id="kEpisodes">0</span></div>
      <div class="item"><b>Avg Reward (100)</b><span id="kAvgRw">0.0</span></div>
      <div class="item"><b>Best Length</b><span id="kBest">0</span></div>
      <div class="item"><b>Fruit Rate</b><span id="kFruitRate">0%</span></div>
    </div>
    <div class="split" style="margin-top:10px">
      <div><h2>Reward / Ep</h2><canvas id="chartReward" class="chart" width="400" height="140"></canvas></div>
      <div><h2>Loss</h2><canvas id="chartLoss" class="chart" width="400" height="140"></canvas></div>
    </div>

    <h2 style="margin-top:14px">Hyperparameters</h2>
    <div class="row">
      <label>γ (discount): <input type="range" id="gamma" min="0.90" max="0.999" step="0.001" value="0.98"></label>
      <label>LR: <input type="range" id="lr" min="0.0001" max="0.005" step="0.0001" value="0.0005"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>ε start: <input type="range" id="epsStart" min="0.2" max="1.0" step="0.05" value="1.0"></label>
      <label>ε end: <input type="range" id="epsEnd" min="0.01" max="0.2" step="0.01" value="0.05"></label>
      <label>ε decay (steps): <input type="range" id="epsDecay" min="5000" max="200000" step="5000" value="40000"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>Batch: <input type="range" id="batchSize" min="32" max="512" step="32" value="128"></label>
      <label>Replay size: <input type="range" id="bufferSize" min="5000" max="200000" step="5000" value="50000"></label>
      <label>Target sync (steps): <input type="range" id="targetSync" min="500" max="10000" step="500" value="2000"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>n-step <span class="mono" id="nStepReadout">3</span>: <input type="range" id="nStep" min="1" max="5" step="1" value="3"></label>
      <label>PER alpha <span class="mono" id="alphaReadout">0.60</span>: <input type="range" id="priorityAlpha" min="0.1" max="1" step="0.05" value="0.6"></label>
      <label>PER beta <span class="mono" id="betaReadout">0.40</span>: <input type="range" id="priorityBeta" min="0.1" max="1" step="0.05" value="0.4"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <label>Beta inc/1k <span class="mono" id="betaIncReadout">0.002</span>: <input type="range" id="priorityBetaInc" min="0" max="0.02" step="0.0005" value="0.002"></label>
      <label>Priority eps <span class="mono" id="priorityEpsReadout">0.0010</span>: <input type="range" id="priorityEps" min="0.0001" max="0.02" step="0.0001" value="0.001"></label>
    </div>
  </div>
</main>

<section id="guideView" class="hidden">
  <div class="card">
    <h2>Vad som ändrats</h2>
    <ul>
      <li>Anti-snurr-straff: svängar kostar lite, loop-mönster kostar mer, samt straff för nyligen besökta rutor.</li>
      <li>Dueling Double DQN + djupare nät (256→256→128) för stabilare inlärning.</li>
      <li>Prioritized replay + n-step returns with sliders for smoother training.</li>
      <li>Curriculum: automatiskt större bräde när det går bra ⇒ klarar mer komplexa layouter.</li>
      <li>Mjukare rendering och mindre risk att renderkön sticker iväg.</li>
    </ul>
  </div>
  <!-- (resten av din guide kan behållas eller uppdateras) -->
</section>

<input type="file" id="fileLoader" accept="application/json" hidden>

<footer class="hint">© Marcus — Snake learns from scratch with DQN (dueling double + anti-loop)</footer>

<script>
/* ---------------- Serialization helpers (samma som tidigare) ---------------- */
const DTYPE_ARRAYS={float32:Float32Array,int32:Int32Array,bool:Uint8Array};
function typedArrayToBase64(arr){ if(!(arr instanceof Float32Array||arr instanceof Int32Array||arr instanceof Uint8Array)){arr=Float32Array.from(arr);}
  const view=new Uint8Array(arr.buffer,arr.byteOffset||0,arr.byteLength); let binary=''; const chunk=0x8000;
  for(let i=0;i<view.length;i+=chunk){binary+=String.fromCharCode.apply(null,view.subarray(i,i+chunk));}
  return btoa(binary);
}
function base64ToTypedArray(str,dtype='float32'){ const binary=atob(str); const len=binary.length; const bytes=new Uint8Array(len);
  for(let i=0;i<len;i++)bytes[i]=binary.charCodeAt(i); const C=DTYPE_ARRAYS[dtype]||Float32Array; return new C(bytes.buffer);
}
function assignArray(target,source,mapper=v=>v){ target.length=0; if(!Array.isArray(source))return; source.forEach(v=>target.push(mapper(v))); }

/* ---------------- Environment med anti-loop ---------------- */
class SnakeEnv {
  constructor(cols=20, rows=20){
    this.cols=cols; this.rows=rows;
    this.reset();
  }
  reset(){
    this.dir={x:1,y:0};
    const cx=(this.cols/2|0), cy=(this.rows/2|0);
    this.snake=[{x:cx-1,y:cy},{x:cx,y:cy}];
    this.snakeSet=new Set(this.snake.map(p=>`${p.x},${p.y}`));
    // besökskarta (decay varje steg)
    this.visit=new Float32Array(this.cols*this.rows).fill(0);
    // historik för åtgärder (för att upptäcka L-R-L-R)
    this.actionHist=[];
    this.spawnFruit();
    this.steps=0; this.stepsSinceFruit=0; this.alive=true;
    return this.getState();
  }
  idx(x,y){return y*this.cols+x}
  spawnFruit(){
    const free=[];
    for(let y=0;y<this.rows;y++)for(let x=0;x<this.cols;x++)
      if(!this.snakeSet.has(`${x},${y}`)) free.push({x,y});
    this.fruit=free.length?free[(Math.random()*free.length)|0]:{x:-1,y:-1};
  }
  turn(a){ const d=this.dir; if(a===1)this.dir={x:-d.y,y:d.x}; else if(a===2)this.dir={x:d.y,y:-d.x}; }
  step(a){
    if(!this.alive) return {state:this.getState(),reward:0,done:true};
    this.turn(a);
    const h=this.snake[0], nx=h.x+this.dir.x, ny=h.y+this.dir.y;
    this.steps++; this.stepsSinceFruit++;

    // vägg/bit-själv
    if(nx<0||ny<0||nx>=this.cols||ny>=this.rows||this.snakeSet.has(`${nx},${ny}`)){
      this.alive=false; return {state:this.getState(),reward:-10,done:true};
    }

    // decay besökskartan lite
    for(let i=0;i<this.visit.length;i++) this.visit[i]*=0.995;

    this.snake.unshift({x:nx,y:ny});
    let r=-0.01; // något mildare bas-stegkostnad

    // svängkostnad (liten)
    if(a!==0) r-=0.005;

    // loop-oscillation: kolla de fyra senaste
    this.actionHist.push(a);
    if(this.actionHist.length>6) this.actionHist.shift();
    if(this.actionHist.length>=4){
      const last4=this.actionHist.slice(-4).join(',');
      // mönster 1,2,1,2 eller 2,1,2,1 ⇒ snurr
      if(last4==='1,2,1,2' || last4==='2,1,2,1') r-=0.10;
    }

    // besöksstraff (nyligen trampad cell) – motverkar cirklar
    const vidx=this.idx(nx,ny);
    const revisitPenalty=this.visit[vidx]*0.02; // skala liten men tydlig
    r -= revisitPenalty;

    if(nx===this.fruit.x && ny===this.fruit.y){
      r+=10; this.snakeSet.add(`${nx},${ny}`); this.spawnFruit(); this.stepsSinceFruit=0;
    } else {
      const tail=this.snake.pop(); this.snakeSet.delete(`${tail.x},${tail.y}`);
      this.snakeSet.add(`${nx},${ny}`);
      // uppdatera besökskarta
      this.visit[vidx]=Math.min(1,this.visit[vidx]+0.3);

      // potential shaping mot frukt
      const pd=Math.abs(h.x-this.fruit.x)+Math.abs(h.y-this.fruit.y);
      const nd=Math.abs(nx-this.fruit.x)+Math.abs(ny-this.fruit.y);
      r+= (nd<pd?0.03:-0.03);
    }

    // stagnation-timeout
    if(this.stepsSinceFruit>this.cols*this.rows*2){
      this.alive=false; r-=5; return {state:this.getState(),reward:r,done:true};
    }
    return {state:this.getState(),reward:r,done:false};
  }
  getState(){
    const h=this.snake[0];
    const L={x:-this.dir.y,y:this.dir.x}, R={x:this.dir.y,y:-this.dir.x};
    const block=(dx,dy)=>{const x=h.x+dx,y=h.y+dy;
      return (x<0||y<0||x>=this.cols||y>=this.rows||this.snakeSet.has(`${x},${y}`))?1:0;};
    const danger=[block(this.dir.x,this.dir.y),block(L.x,L.y),block(R.x,R.y)];
    const dir=[this.dir.y===-1?1:0,this.dir.y===1?1:0,this.dir.x===-1?1:0,this.dir.x===1?1:0];
    const fruit=[this.fruit.y<h.y?1:0,this.fruit.y>h.y?1:0,this.fruit.x<h.x?1:0,this.fruit.x>h.x?1:0];
    const dists=[h.y/(this.rows-1),(this.rows-1-h.y)/(this.rows-1),h.x/(this.cols-1),(this.cols-1-h.x)/(this.cols-1)];
    const dx=this.fruit.x-h.x, dy=this.fruit.y-h.y, len=Math.hypot(dx,dy)||1;
    // lägg till “trängsel” från besökskarta runt huvudet (4-grannar)
    const crowd = [
      this.getVisit(h.x, h.y-1),
      this.getVisit(h.x, h.y+1),
      this.getVisit(h.x-1, h.y),
      this.getVisit(h.x+1, h.y),
    ];
    return Float32Array.from([...danger,...dir,...fruit,...dists,dy/len,dx/len,...crowd]);
  }
  getVisit(x,y){
    if(x<0||y<0||x>=this.cols||y>=this.rows) return 1; // utanför = “trångt”
    return this.visit[this.idx(x,y)]||0;
  }
}

/* ---------------- ReplayBuffer (oförändrat) ---------------- */
class NStepAccumulator{
  constructor(n=1,gamma=0.99){
    this.setConfig(n,gamma);
  }
  setConfig(n,gamma){
    this.n=Math.max(1,n|0);
    this.gamma=gamma;
    this.queue=[];
  }
  push(step){
    const item={
      s:Float32Array.from(step.s),
      a:step.a|0,
      r:+step.r,
      ns:Float32Array.from(step.ns),
      d:!!step.d,
    };
    this.queue.push(item);
    const ready=[];
    while(this.queue.length>=this.n){
      ready.push(this.build());
      this.queue.shift();
      if(ready[ready.length-1].d){
        this.queue.length=0;
        return ready;
      }
    }
    if(item.d){
      ready.push(...this.flush());
    }
    return ready;
  }
  build(){
    let reward=0;
    let discount=1;
    let done=false;
    let nextState=this.queue[0].ns;
    const limit=Math.min(this.n,this.queue.length);
    for(let i=0;i<limit;i++){
      const step=this.queue[i];
      reward+=discount*step.r;
      discount*=this.gamma;
      nextState=step.ns;
      if(step.d){
        done=true;
        break;
      }
    }
    const first=this.queue[0];
    return {s:first.s,a:first.a,r:reward,ns:nextState,d:done};
  }
  flush(){
    const out=[];
    while(this.queue.length){
      out.push(this.build());
      this.queue.shift();
    }
    return out;
  }
}

class ReplayBuffer{
  constructor(cap=50000,opts={}){
    this.cap=Math.max(1,cap|0);
    this.buf=[];
    this.pos=0;
    this.alpha=opts.alpha??0.6;
    this.beta=opts.beta??0.4;
    this.betaIncrement=opts.betaIncrement??0.000002;
    this.priorityEps=opts.priorityEps??0.001;
    this.priorities=new Float32Array(this.cap);
    this.maxPriority=this.priorityEps;
  }
  size(){return this.buf.length;}
  setAlpha(val){this.alpha=Math.max(0.01,+val||0.01);}
  setBeta(val){this.beta=Math.min(1,Math.max(0,+val||0));}
  setBetaIncrement(val){this.betaIncrement=Math.max(0,+val||0);}
  setPriorityEps(val){
    this.priorityEps=Math.max(1e-6,+val||1e-6);
    for(let i=0;i<this.buf.length;i++){
      if(this.priorities[i]<this.priorityEps){
        this.priorities[i]=this.priorityEps;
      }
    }
    this.maxPriority=Math.max(this.maxPriority,this.priorityEps);
  }
  setCapacity(cap){
    cap=Math.max(1,cap|0);
    if(cap===this.cap)return;
    if(cap<this.buf.length){
      const start=this.buf.length-cap;
      this.buf=this.buf.slice(start);
      const next=new Float32Array(cap);
      for(let i=0;i<cap;i++)next[i]=this.priorities[start+i];
      this.priorities=next;
    } else {
      const next=new Float32Array(cap);
      next.set(this.priorities.slice(0,this.buf.length));
      this.priorities=next;
    }
    this.cap=cap;
    this.pos=this.buf.length%this.cap;
    this.maxPriority=this.priorityEps;
    for(let i=0;i<this.buf.length;i++){
      this.maxPriority=Math.max(this.maxPriority,this.priorities[i]);
    }
  }
  push(s,a,r,ns,d,priority){
    if(typeof s==='object'&&s!==null&&s.s!==undefined){
      ({s,a,r,ns,d,priority}=s);
    }
    const entry={
      s:Float32Array.from(s),
      a:a|0,
      r:+r,
      ns:Float32Array.from(ns),
      d:!!d,
    };
    const p=Math.max(priority??this.maxPriority,this.priorityEps);
    if(this.buf.length<this.cap){
      this.buf.push(entry);
      this.priorities[this.buf.length-1]=p;
    } else {
      this.buf[this.pos]=entry;
      this.priorities[this.pos]=p;
    }
    this.maxPriority=Math.max(this.maxPriority,p);
    this.pos=(this.pos+1)%this.cap;
  }
  sample(n){
    const size=this.buf.length;
    if(!size)return null;
    const count=Math.min(n,size);
    const powered=new Float32Array(size);
    let total=0;
    for(let i=0;i<size;i++){
      const pow=Math.pow(this.priorities[i],this.alpha);
      powered[i]=pow;
      total+=pow;
    }
    if(total<=0){
      for(let i=0;i<size;i++)powered[i]=1;
      total=size;
    }
    const cdf=new Float32Array(size);
    let cumulative=0;
    for(let i=0;i<size;i++){
      cumulative+=powered[i];
      cdf[i]=cumulative;
    }
    const batch=[];
    const idxs=new Array(count);
    const weights=new Float32Array(count);
    let maxWeight=0;
    for(let k=0;k<count;k++){
      const target=Math.random()*total;
      let l=0,h=size-1;
      while(l<h){
        const mid=(l+h)>>>1;
        if(target<=cdf[mid])h=mid; else l=mid+1;
      }
      const idx=l;
      idxs[k]=idx;
      batch.push(this.buf[idx]);
      const prob=powered[idx]/total;
      const weight=Math.pow(size*prob,-this.beta);
      weights[k]=weight;
      if(weight>maxWeight)maxWeight=weight;
    }
    if(maxWeight>0){
      for(let i=0;i<count;i++)weights[i]/=maxWeight;
    }
    this.beta=Math.min(1,this.beta+this.betaIncrement);
    return {batch,idxs,weights:Array.from(weights)};
  }
  updatePriorities(idxs,values){
    if(!idxs||!values)return;
    const valArr=Array.from(values);
    for(let i=0;i<idxs.length;i++){
      const idx=idxs[i];
      if(idx<0||idx>=this.buf.length)continue;
      const raw=valArr[i]??0;
      const p=Math.max(Math.abs(raw),this.priorityEps);
      this.priorities[idx]=p;
      this.maxPriority=Math.max(this.maxPriority,p);
    }
  }
  toJSON(){
    return {
      cap:this.cap,
      pos:this.pos,
      alpha:this.alpha,
      beta:this.beta,
      betaIncrement:this.betaIncrement,
      priorityEps:this.priorityEps,
      maxPriority:this.maxPriority,
      priorities:Array.from(this.priorities.slice(0,this.buf.length)),
      buf:this.buf.map(item=>({
        s:typedArrayToBase64(item.s),
        a:item.a,
        r:item.r,
        ns:typedArrayToBase64(item.ns),
        d:item.d?1:0,
      })),
    };
  }
  static fromJSON(data={},overrideCap,overrides={}){
    const cap=overrideCap??(typeof data.cap==='number'?data.cap:50000);
    const opts={
      alpha:overrides.alpha??data.alpha??0.6,
      beta:overrides.beta??data.beta??0.4,
      betaIncrement:overrides.betaIncrement??data.betaIncrement??0.000002,
      priorityEps:overrides.priorityEps??data.priorityEps??0.001,
    };
    const buffer=new ReplayBuffer(cap,opts);
    const entries=Array.isArray(data.buf)?data.buf:[];
    const priorities=Array.isArray(data.priorities)?data.priorities:[];
    const fallback=Math.max(buffer.priorityEps,typeof data.maxPriority==='number'?data.maxPriority:1);
    const entrySlice=entries.slice(-cap);
    const prioSlice=priorities.slice(-cap);
    entrySlice.forEach((entry,idx)=>{
      const priority=prioSlice[idx]??fallback;
      buffer.push({
        s:base64ToTypedArray(entry.s,'float32'),
        a:entry.a,
        r:entry.r,
        ns:base64ToTypedArray(entry.ns,'float32'),
        d:!!entry.d,
        priority,
      });
    });
    buffer.pos=buffer.buf.length%buffer.cap;
    buffer.maxPriority=buffer.priorityEps;
    for(let i=0;i<buffer.buf.length;i++){
      buffer.maxPriority=Math.max(buffer.maxPriority,buffer.priorities[i]);
    }
    buffer.beta=opts.beta;
    buffer.betaIncrement=opts.betaIncrement;
    return buffer;
  }
}

/* ---------------- Dueling Double DQN (djupare nät) ---------------- */
class DQN{
  constructor(sDim,aDim,cfg){
    this.sDim=sDim; this.aDim=aDim;
    this.gamma=cfg.gamma;
    this.lr=cfg.lr;
    this.batch=cfg.batch;
    this.priorityEps=cfg.priorityEps??0.001;
    this.buffer=new ReplayBuffer(cfg.bufferSize,{
      alpha:cfg.priorityAlpha,
      beta:cfg.priorityBeta,
      betaIncrement:cfg.priorityBetaIncrement,
      priorityEps:this.priorityEps,
    });
    this.priorityEps=this.buffer.priorityEps;
    this.epsStart=cfg.epsStart; this.epsEnd=cfg.epsEnd; this.epsDecay=cfg.epsDecay;
    this.nStep=cfg.nStep??1;
    this.nStepBuffer=new NStepAccumulator(this.nStep,this.gamma);
    this.trainStep=0; this.updateEpsilon(0);
    this.online=this.build(); this.target=this.build(); this.syncTarget();
    this.optimizer=tf.train.adam(this.lr);
  }
  build(){
    const input=tf.input({shape:[this.sDim]});
    const d1=tf.layers.dense({units:256,activation:'relu',kernelInitializer:'heNormal'}).apply(input);
    const d2=tf.layers.dense({units:256,activation:'relu',kernelInitializer:'heNormal'}).apply(d1);
    const d3=tf.layers.dense({units:128,activation:'relu',kernelInitializer:'heNormal'}).apply(d2);
    const adv=tf.layers.dense({units:128,activation:'relu',kernelInitializer:'heNormal'}).apply(d3);
    const advOut=tf.layers.dense({units:this.aDim,activation:'linear'}).apply(adv);
    const val=tf.layers.dense({units:128,activation:'relu',kernelInitializer:'heNormal'}).apply(d3);
    const valOut=tf.layers.dense({units:1,activation:'linear'}).apply(val);
    const q=tf.layers.add().apply([advOut,valOut]);
    return tf.model({inputs:input,outputs:q});
  }
  setGamma(val){
    this.gamma=val;
    this.nStepBuffer.setConfig(this.nStep,this.gamma);
  }
  setLearningRate(val){
    this.lr=val;
    this.optimizer=tf.train.adam(this.lr);
  }
  setNStep(val){
    const n=Math.max(1,val|0);
    if(n===this.nStep)return;
    this.nStep=n;
    this.nStepBuffer.setConfig(this.nStep,this.gamma);
  }
  recordTransition(s,a,r,ns,d){
    const ready=this.nStepBuffer.push({s,a,r,ns,d});
    if(ready.length) ready.forEach(t=>this.buffer.push(t));
    if(d){
      const tail=this.nStepBuffer.flush();
      if(tail.length) tail.forEach(t=>this.buffer.push(t));
    }
  }
  drainPending(){
    const tail=this.nStepBuffer.flush();
    if(tail.length) tail.forEach(t=>this.buffer.push(t));
  }
  syncTarget(){ this.target.setWeights(this.online.getWeights()); }
  updateEpsilon(step){ const t=Math.min(1,step/this.epsDecay); this.epsilon=this.epsStart*(1-t)+this.epsEnd*t; return this.epsilon; }
  act(s){
    if(Math.random()<this.epsilon) return (Math.random()*this.aDim)|0;
    return tf.tidy(()=>this.online.predict(tf.tensor2d([s],[1,this.sDim])).argMax(1).dataSync()[0]);
  }
  async learn(){
    if(this.buffer.size()<this.batch) return null;
    const sample=this.buffer.sample(this.batch);
    if(!sample||!sample.batch.length) return null;
    const {batch,idxs,weights}=sample;
    const S=tf.tensor2d(batch.map(x=>x.s),[batch.length,this.sDim]);
    const NS=tf.tensor2d(batch.map(x=>x.ns),[batch.length,this.sDim]);
    const A=tf.tensor1d(batch.map(x=>x.a),'int32');
    const R=tf.tensor1d(batch.map(x=>x.r));
    const D=tf.tensor1d(batch.map(x=>x.d?1:0));
    const W=tf.tensor1d(weights);
    let tdErrors;
    const lossTensor=await this.optimizer.minimize(()=>{
      const q=this.online.apply(S);
      const qPred=tf.sum(q.mul(tf.oneHot(A,this.aDim)),1);
      const qNextOnline=this.online.apply(NS);
      const aPrime=tf.argMax(qNextOnline,1);
      const oh=tf.oneHot(aPrime,this.aDim);
      const qNextTarget=this.target.apply(NS);
      const qNext=tf.sum(qNextTarget.mul(oh),1);
      const target=R.add(qNext.mul(tf.scalar(this.gamma)).mul(tf.scalar(1).sub(D)));
      tdErrors=tf.keep(target.sub(qPred));
      const absErr=tdErrors.abs();
      const quadratic=tf.minimum(absErr,tf.scalar(1));
      const linear=absErr.sub(quadratic);
      const losses=quadratic.square().mul(0.5).add(linear);
      return losses.mul(W).mean();
    }, true);
    const loss=lossTensor.dataSync()[0];
    lossTensor.dispose();
    const absTd=tdErrors.abs();
    const tdArray=absTd.dataSync();
    absTd.dispose();
    tdErrors.dispose();
    S.dispose(); NS.dispose(); A.dispose(); R.dispose(); D.dispose(); W.dispose();
    this.buffer.updatePriorities(idxs,tdArray);
    this.trainStep++;
    return loss;
  }
  async exportState(){
    const weights=await Promise.all(this.online.getWeights().map(async w=>({
      shape:w.shape, dtype:w.dtype, data:typedArrayToBase64(await w.data()),
    })));
    return {
      version:3,
      sDim:this.sDim, aDim:this.aDim,
      config:{
        gamma:this.gamma,
        lr:this.lr,
        batch:this.batch,
        bufferSize:this.buffer.cap,
        epsStart:this.epsStart, epsEnd:this.epsEnd, epsDecay:this.epsDecay,
        nStep:this.nStep,
        priorityAlpha:this.buffer.alpha,
        priorityBeta:this.buffer.beta,
        priorityBetaIncrement:this.buffer.betaIncrement,
        priorityEps:this.buffer.priorityEps,
      },
      trainStep:this.trainStep, epsilon:this.epsilon, buffer:this.buffer.toJSON(), weights,
    };
  }
  async importState(state){
    if(!state)throw new Error('Ogiltigt tillstånd');
    if(state.sDim&&state.sDim!==this.sDim)throw new Error('State-dimension matchar inte');
    if(state.aDim&&state.aDim!==this.aDim)throw new Error('Action-dimension matchar inte');
    const cfg=state.config??{};
    this.setGamma(cfg.gamma??this.gamma);
    this.setLearningRate(cfg.lr??this.lr);
    this.batch=cfg.batch??this.batch;
    this.buffer=ReplayBuffer.fromJSON(state.buffer,cfg.bufferSize,{
      alpha:cfg.priorityAlpha,
      beta:cfg.priorityBeta,
      betaIncrement:cfg.priorityBetaIncrement,
      priorityEps:cfg.priorityEps,
    });
    this.priorityEps=this.buffer.priorityEps;
    this.epsStart=cfg.epsStart??this.epsStart; this.epsEnd=cfg.epsEnd??this.epsEnd; this.epsDecay=cfg.epsDecay??this.epsDecay;
    this.nStep=cfg.nStep??this.nStep;
    this.nStepBuffer=new NStepAccumulator(this.nStep,this.gamma);
    this.trainStep=state.trainStep??this.trainStep;
    this.optimizer=tf.train.adam(this.lr);
    if(Array.isArray(state.weights)){
      const tensors=state.weights.map(w=>tf.tensor(base64ToTypedArray(w.data,w.dtype),w.shape,w.dtype));
      this.online.setWeights(tensors); tensors.forEach(t=>t.dispose());
    }
    this.target=this.build(); this.syncTarget();
    this.epsilon=state.epsilon??this.updateEpsilon(this.trainStep);
  }
}

/* ---------------- Mini chart (samma som tidigare) ---------------- */
class MiniLine{
  constructor(cv,max=400){this.cv=cv;this.ctx=cv.getContext('2d');this.max=max;this.data=[];}
  push(v){this.data.push(v);if(this.data.length>this.max)this.data.shift();this.draw();}
  draw(){ const c=this.ctx,w=this.cv.width,h=this.cv.height;
    c.clearRect(0,0,w,h);c.fillStyle='#0b1030';c.fillRect(0,0,w,h);
    c.strokeStyle='#1b1f3a'; for(let i=0;i<=4;i++){c.beginPath();c.moveTo(0,i*h/4);c.lineTo(w,i*h/4);c.stroke();}
    if(!this.data.length)return; const min=Math.min(...this.data),max=Math.max(...this.data),pad=1e-6;
    c.beginPath();c.strokeStyle='#6c7bff';c.lineWidth=2;
    this.data.forEach((v,i)=>{ const x=(i/(this.data.length-1))*w; const y=h-((v-min)/(max-min+pad))*h; if(i===0)c.moveTo(x,y);else c.lineTo(x,y); });
    c.stroke();
  }
}

/* ---------------- App wiring ---------------- */
const board=document.getElementById('board'), bctx=board.getContext('2d');
let COLS=20,ROWS=20,CELL=board.width/COLS;
let env=new SnakeEnv(COLS,ROWS);

function snapshotEnv(environment){
  return {
    snake:environment.snake.map(p=>({x:p.x,y:p.y})),
    fruit:environment.fruit?{x:environment.fruit.x,y:environment.fruit.y}:{x:-1,y:-1},
  };
}
const cloneState=state=>({ snake:state.snake.map(p=>({x:p.x,y:p.y})), fruit:{x:state.fruit.x,y:state.fruit.y} });

const BG_COLOR='#0f1328', GRID_COLOR='#17204a', HEAD_COLOR='#23d18b', BODY_COLOR='#6c7bff';
let lastDrawnState=snapshotEnv(env);
let renderQueue=[], currentAnim=null, renderActive=false, renderToken=0, watching=false;
const MAX_RENDER_QUEUE=200;
const queueLimit=()=>watching?MAX_RENDER_QUEUE*3:MAX_RENDER_QUEUE;

function setImmediateState(environment){
  const state=snapshotEnv(environment);
  if(renderToken){cancelAnimationFrame(renderToken);renderToken=0;}
  renderActive=false; renderQueue.length=0; currentAnim=null; lastDrawnState=cloneState(state); drawFrame(state,state,1);
}
function enqueueRenderFrame(from,to,duration=getAnimDuration()){
  const entry={from:cloneState(from),to:cloneState(to),start:null,duration};
  renderQueue.push(entry);
  const limit=queueLimit();
  if(renderQueue.length>limit){
    const latest=renderQueue[renderQueue.length-1];
    renderQueue=[{from:cloneState(lastDrawnState),to:cloneState(latest.to),start:null,duration:Math.max(40,duration*0.5)}];
    currentAnim=null;
  }
  if(!renderActive){ renderActive=true; renderToken=requestAnimationFrame(stepRender); }
}
function getAnimDuration(){ const maxFps=ui&&ui.fpsLimit?+ui.fpsLimit.value:60; return Math.max(16,1000/Math.max(10,maxFps)); }
function getWatchDuration(){ const maxFps=ui&&ui.fpsLimit?+ui.fpsLimit.value:60; const capped=Math.min(Math.max(10,maxFps),240); return Math.max(12,1000/capped); }
function stepRender(ts){
  if(!currentAnim){ currentAnim=renderQueue.shift(); if(!currentAnim){ renderActive=false; renderToken=0; drawFrame(lastDrawnState,lastDrawnState,1); return; } }
  if(currentAnim.start===null)currentAnim.start=ts;
  const duration=currentAnim.duration??getAnimDuration();
  const progress=duration<=0?1:Math.min(1,(ts-currentAnim.start)/duration);
  drawFrame(currentAnim.from,currentAnim.to,progress);
  if(progress>=1){ lastDrawnState=cloneState(currentAnim.to); currentAnim=null; }
  renderToken=requestAnimationFrame(stepRender);
}
const waitAnimationFrame=()=>new Promise(res=>requestAnimationFrame(res));
async function waitForRenderCapacity(limit=Math.max(10,Math.floor(queueLimit()*0.6))){ while(renderQueue.length>limit){ await waitAnimationFrame(); } }
async function waitForRenderIdle(){ while(renderQueue.length>0||currentAnim){ await waitAnimationFrame(); } }

function drawFrame(from,to,t){
  bctx.fillStyle=BG_COLOR; bctx.fillRect(0,0,board.width,board.height); drawGrid();
  const sameFruit=from.fruit.x===to.fruit.x&&from.fruit.y===to.fruit.y;
  if(from.fruit.x>=0&&!sameFruit)drawFruit(from.fruit,1-t);
  if(to.fruit.x>=0)drawFruit(to.fruit,sameFruit?1:t);
  const fromSnake=from.snake, toSnake=to.snake;
  const grew=toSnake.length>fromSnake.length; const shrank=toSnake.length<fromSnake.length; const offset=shrank?fromSnake.length-toSnake.length:0;
  const segments=toSnake.map((seg,i)=>{
    let start;
    if(grew){ start=i===0?fromSnake[0]:fromSnake[i-1]??fromSnake[fromSnake.length-1]; }
    else if(shrank){ start=fromSnake[i+offset]??fromSnake[fromSnake.length-1]; }
    else { start=fromSnake[i]??fromSnake[fromSnake.length-1]; }
    const sx=(start?.x??seg.x), sy=(start?.y??seg.y);
    return {x:sx+(seg.x-sx)*t,y:sy+(seg.y-sy)*t};
  });
  drawSnakeSegments(segments);
}
function drawGrid(){ bctx.strokeStyle=GRID_COLOR; bctx.lineWidth=1;
  for(let x=0;x<=COLS;x++){ bctx.beginPath(); bctx.moveTo(x*CELL,0); bctx.lineTo(x*CELL,board.height); bctx.stroke(); }
  for(let y=0;y<=ROWS;y++){ bctx.beginPath(); bctx.moveTo(0,y*CELL); bctx.lineTo(board.width,y*CELL); bctx.stroke(); }
}
function drawFruit(pos,alpha=1){ if(alpha<=0)return; bctx.save(); bctx.globalAlpha=alpha;
  const fx=pos.x*CELL+CELL/2, fy=pos.y*CELL+CELL/2; bctx.fillStyle='#ff5aa4'; bctx.beginPath(); bctx.arc(fx,fy,CELL/3,0,2*Math.PI); bctx.fill(); bctx.restore();
}
function drawSnakeSegments(segments){ segments.forEach((p,i)=>drawSegment(p.x,p.y,i===0)); }
function drawSegment(x,y,isHead){ const px=x*CELL+1, py=y*CELL+1, size=CELL-2; const baseRadius=isHead?Math.max(4,CELL*0.3):Math.max(3,CELL*0.25);
  const radius=Math.min(baseRadius,size/2); bctx.fillStyle=isHead?HEAD_COLOR:BODY_COLOR;
  if(typeof bctx.roundRect==='function'){ bctx.beginPath(); bctx.roundRect(px,py,size,size,radius); bctx.fill(); } else { bctx.fillRect(px,py,size,size); }
}

/* ---------------- Init agent ---------------- */
let stateDim=env.getState().length, actionDim=3;
const cfg={
  gamma:0.98,
  lr:0.0005,
  batch:128,
  bufferSize:50000,
  epsStart:1.0,
  epsEnd:0.05,
  epsDecay:40000,
  nStep:3,
  priorityAlpha:0.6,
  priorityBeta:0.4,
  priorityBetaIncrement:0.000002,
  priorityEps:0.001,
};
let agent;

/* ---------------- UI refs ---------------- */
const ui={
  trainState:document.getElementById('trainState'),epsReadout:document.getElementById('epsReadout'),
  gamma:document.getElementById('gamma'),gammaReadout:document.getElementById('gammaReadout'),
  lr:document.getElementById('lr'),lrReadout:document.getElementById('lrReadout'),
  epsStart:document.getElementById('epsStart'),epsEnd:document.getElementById('epsEnd'),
  epsDecay:document.getElementById('epsDecay'),batchSize:document.getElementById('batchSize'),
  bufferSize:document.getElementById('bufferSize'),targetSync:document.getElementById('targetSync'),
  nStep:document.getElementById('nStep'),nStepReadout:document.getElementById('nStepReadout'),
  priorityAlpha:document.getElementById('priorityAlpha'),alphaReadout:document.getElementById('alphaReadout'),
  priorityBeta:document.getElementById('priorityBeta'),betaReadout:document.getElementById('betaReadout'),
  priorityBetaInc:document.getElementById('priorityBetaInc'),betaIncReadout:document.getElementById('betaIncReadout'),
  priorityEps:document.getElementById('priorityEps'),priorityEpsReadout:document.getElementById('priorityEpsReadout'),
  gridSize:document.getElementById('gridSize'),gridLabel:document.getElementById('gridLabel'),
  renderEvery:document.getElementById('renderEvery'),renderLabel:document.getElementById('renderLabel'),
  fpsLimit:document.getElementById('fpsLimit'),fpsLabel:document.getElementById('fpsLabel'),
  kEpisodes:document.getElementById('kEpisodes'),kAvgRw:document.getElementById('kAvgRw'),
  kBest:document.getElementById('kBest'),kFruitRate:document.getElementById('kFruitRate'),
  btnTrain:document.getElementById('btnTrain'),btnPause:document.getElementById('btnPause'),
  btnStep:document.getElementById('btnStep'),btnWatch:document.getElementById('btnWatch'),
  btnReset:document.getElementById('btnReset'),
  btnSave:document.getElementById('btnSave'),btnLoad:document.getElementById('btnLoad'),
  btnClear:document.getElementById('btnClear'),
  tabTraining:document.getElementById('tabTraining'),tabGuide:document.getElementById('tabGuide'),
  trainingView:document.getElementById('trainingView'),guideView:document.getElementById('guideView'),
  fileLoader:document.getElementById('fileLoader'),
  chartReward:new MiniLine(document.getElementById('chartReward')),
  chartLoss:new MiniLine(document.getElementById('chartLoss')),
};

let activeTab='training';
function setActiveTab(tab){
  const showGuide=tab==='guide'; activeTab=showGuide?'guide':'training';
  ui.tabTraining.classList.toggle('active',!showGuide);
  ui.tabGuide.classList.toggle('active',showGuide);
  ui.trainingView.classList.toggle('hidden',showGuide);
  ui.guideView.classList.toggle('hidden',!showGuide);
}

window.addEventListener('load',async()=>{
  agent=new DQN(stateDim,actionDim,cfg);
  bindUI();
  setImmediateState(env);
});

function bindUI(){
  const update=()=>{
    const gammaVal=+ui.gamma.value;
    agent.setGamma(gammaVal);
    ui.gammaReadout.textContent=gammaVal.toFixed(3);

    const lrVal=+ui.lr.value;
    agent.setLearningRate(lrVal);
    ui.lrReadout.textContent=lrVal.toFixed(4);

    agent.epsStart=+ui.epsStart.value;
    agent.epsEnd=+ui.epsEnd.value;
    agent.epsDecay=+ui.epsDecay.value;

    agent.batch=+ui.batchSize.value;
    agent.buffer.setCapacity(+ui.bufferSize.value);

    const nStepVal=+ui.nStep.value;
    agent.setNStep(nStepVal);
    ui.nStepReadout.textContent=nStepVal.toString();

    const alphaVal=+ui.priorityAlpha.value;
    agent.buffer.setAlpha(alphaVal);
    ui.alphaReadout.textContent=alphaVal.toFixed(2);

    const betaVal=+ui.priorityBeta.value;
    agent.buffer.setBeta(betaVal);
    ui.betaReadout.textContent=betaVal.toFixed(2);

    const betaIncVal=+ui.priorityBetaInc.value;
    agent.buffer.setBetaIncrement(betaIncVal/1000);
    ui.betaIncReadout.textContent=betaIncVal.toFixed(3);

    const priorityEpsVal=+ui.priorityEps.value;
    agent.buffer.setPriorityEps(priorityEpsVal);
    ui.priorityEpsReadout.textContent=priorityEpsVal.toFixed(4);

    ui.epsReadout.textContent=agent.epsilon.toFixed(2);
  };
  ui.applyConfigFromInputs=update;
  ['gamma','lr','epsStart','epsEnd','epsDecay','batchSize','bufferSize','targetSync','nStep','priorityAlpha','priorityBeta','priorityBetaInc','priorityEps'].forEach(id=>ui[id].addEventListener('input',update));
  ui.gridSize.addEventListener('input',()=>ui.gridLabel.textContent=`${ui.gridSize.value}×${ui.gridSize.value}`);
  const updateRenderEvery=()=>{
    const val=+ui.renderEvery.value; ui.renderLabel.textContent=val===1?'1 step':`${val} steps`; renderEvery=val;
  };
  ui.updateRenderEvery=updateRenderEvery; ui.renderEvery.addEventListener('input',updateRenderEvery);
  ui.fpsLimit.addEventListener('input',()=>ui.fpsLabel.textContent=ui.fpsLimit.value);

  ui.btnReset.onclick=()=>{env=new SnakeEnv(+ui.gridSize.value,+ui.gridSize.value);
    COLS=env.cols;ROWS=env.rows;CELL=board.width/COLS; setImmediateState(env); stateDim=env.getState().length;};

  ui.btnTrain.onclick=startTraining;
  ui.btnPause.onclick=stopTraining;
  ui.btnStep.onclick=async()=>{await runEpisodes(1);};
  ui.btnWatch.onclick=watchSmoothEpisode;
  ui.btnSave.onclick=saveTrainingToFile;
  ui.btnLoad.onclick=()=>{ui.fileLoader?.click();};
  ui.fileLoader?.addEventListener('change',async ev=>{
    const [file]=ev.target.files||[]; if(file)await loadTrainingFromFile(file); ev.target.value='';
  });
  ui.btnClear.onclick=()=>{for(const k in localStorage){if(k.includes('tensorflowjs'))localStorage.removeItem(k);}flash('Rensade lokal lagring');};
  ui.tabTraining.onclick=()=>setActiveTab('training');
  ui.tabGuide.onclick=()=>setActiveTab('guide');

  update(); updateRenderEvery();
  ui.gridLabel.textContent=`${ui.gridSize.value}×${ui.gridSize.value}`;
  ui.fpsLabel.textContent=ui.fpsLimit.value;
  setActiveTab('training');
}

async function buildAppState(){
  const agentState=await agent.exportState();
  return {
    version:2, createdAt:new Date().toISOString(),
    agent:agentState,
    meta:{ episode,totalSteps,bestLen,rwHist:Array.from(rwHist),fruitHist:Array.from(fruitHist),lossHist:Array.from(lossHist),
      chartReward:Array.from(ui.chartReward.data), chartLoss:Array.from(ui.chartLoss.data),
      targetSync:+ui.targetSync.value, gridSize:+ui.gridSize.value, renderEvery:+ui.renderEvery.value, fpsLimit:+ui.fpsLimit.value,
    },
  };
}
function applyLoadedConfig(config={}){ if(config.gamma!==undefined)ui.gamma.value=config.gamma;
  if(config.lr!==undefined)ui.lr.value=config.lr; if(config.batch!==undefined)ui.batchSize.value=config.batch;
  if(config.bufferSize!==undefined)ui.bufferSize.value=config.bufferSize;
  if(config.epsStart!==undefined)ui.epsStart.value=config.epsStart;
  if(config.epsEnd!==undefined)ui.epsEnd.value=config.epsEnd;
  if(config.epsDecay!==undefined)ui.epsDecay.value=config.epsDecay;
  if(config.nStep!==undefined)ui.nStep.value=config.nStep;
  if(config.priorityAlpha!==undefined)ui.priorityAlpha.value=config.priorityAlpha;
  if(config.priorityBeta!==undefined)ui.priorityBeta.value=config.priorityBeta;
  if(config.priorityBetaIncrement!==undefined)ui.priorityBetaInc.value=(+config.priorityBetaIncrement)*1000;
  if(config.priorityEps!==undefined)ui.priorityEps.value=config.priorityEps;
  ui.applyConfigFromInputs?.();
}
function applyMeta(meta={}){ episode=+meta.episode||0; totalSteps=+meta.totalSteps||0; bestLen=+meta.bestLen||0;
  assignArray(rwHist,meta.rwHist,v=>+v||0); assignArray(fruitHist,meta.fruitHist,v=>+v||0); assignArray(lossHist,meta.lossHist,v=>+v||0);
  ui.chartReward.data=Array.isArray(meta.chartReward)?meta.chartReward.map(v=>+v||0):[]; ui.chartReward.draw();
  ui.chartLoss.data=Array.isArray(meta.chartLoss)?meta.chartLoss.map(v=>+v||0):[]; ui.chartLoss.draw();
  ui.kEpisodes.textContent=episode; ui.kAvgRw.textContent=avg(rwHist,100).toFixed(2); ui.kBest.textContent=bestLen; ui.kFruitRate.textContent=avg(fruitHist,100).toFixed(2);
  if(typeof meta.targetSync==='number')ui.targetSync.value=meta.targetSync;
  if(typeof meta.gridSize==='number'){ ui.gridSize.value=meta.gridSize; ui.gridLabel.textContent=`${meta.gridSize}×${meta.gridSize}`;
    env=new SnakeEnv(meta.gridSize,meta.gridSize); COLS=env.cols;ROWS=env.rows;CELL=board.width/COLS;
  } else { ui.gridLabel.textContent=`${ui.gridSize.value}×${ui.gridSize.value}`; }
  if(typeof meta.renderEvery==='number') ui.renderEvery.value=meta.renderEvery; ui.updateRenderEvery?.();
  if(typeof meta.fpsLimit==='number') ui.fpsLimit.value=meta.fpsLimit; ui.fpsLabel.textContent=ui.fpsLimit.value;
  env.reset(); setImmediateState(env);
}
async function saveTrainingToFile(){
  if(!agent)return; const resume=training; if(resume)stopTraining();
  try{
    await waitForRenderIdle(); const state=await buildAppState();
    const blob=new Blob([JSON.stringify(state,null,2)],{type:'application/json'});
    const stamp=new Date().toISOString().replace(/[:.]/g,'-');
    const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=`snake-training-${stamp}.json`;
    document.body.appendChild(a); a.click(); document.body.removeChild(a); setTimeout(()=>URL.revokeObjectURL(url),1000);
    flash('Sparat till fil');
  } catch(err){ console.error(err); flash('Kunde inte spara',true); }
  finally{ if(resume&&!watching)startTraining(); }
}
async function loadTrainingFromFile(file){
  if(!agent||!file)return; if(watching){ flash('Avsluta visningsläget först',true); return; }
  const resume=training; if(resume)stopTraining();
  try{
    const text=await file.text(); const data=JSON.parse(text);
    if(!data||!data.agent)throw new Error('Ogiltig sparfil');
    await agent.importState(data.agent); applyLoadedConfig(data.agent.config||{}); applyMeta(data.meta||{});
    ui.epsReadout.textContent=agent.epsilon.toFixed(2); flash('Laddat från fil');
  } catch(err){ console.error(err); flash('Kunde inte ladda',true); }
  finally{ if(resume&&!watching)startTraining(); }
}

/* ---------------- Training loop + curriculum ---------------- */
let training=false,animToken=0,lastFrame=0,renderEvery=1;
let episode=0,totalSteps=0,bestLen=0;
const rwHist=[],fruitHist=[],lossHist=[];
function avg(a,n){return a.slice(-n).reduce((x,y)=>x+y,0)/Math.max(1,Math.min(a.length,n));}
function flash(m,d=false){ ui.trainState.textContent=m; ui.trainState.style.background=d?'#ff4b6e':'#1a1f46';
  setTimeout(()=>{ if(watching){ ui.trainState.textContent='watching'; ui.trainState.style.background='#1a1f46'; return; }
    ui.trainState.textContent=training?'training':'idle'; ui.trainState.style.background='#1a1f46'; },1200);
}

async function startTraining(){ if(training||watching)return;
  training=true; ui.trainState.textContent='training'; ui.trainState.style.background='#1a1f46';
  renderEvery=+ui.renderEvery.value; lastFrame=0; animToken=requestAnimationFrame(loopTrain);
}
function stopTraining(){ if(!training)return; training=false; cancelAnimationFrame(animToken); animToken=0; ui.trainState.textContent='idle'; ui.trainState.style.background='#1a1f46'; }

async function loopTrain(ts){
  if(!training||watching){animToken=0;return;}
  const maxFps=+ui.fpsLimit.value;
  if(ts-lastFrame<1000/maxFps){ animToken=requestAnimationFrame(loopTrain); return; }
  lastFrame=ts;
  // kör korta episoder per frame för jämnare UI
  await runEpisodes(1,true);
  if(!training||watching){animToken=0;return;}
  animToken=requestAnimationFrame(loopTrain);
}

async function runEpisodes(count=1,respectStop=false){
  if(watching)return;
  const targetSync=+ui.targetSync.value;
  for(let e=0;e<count;e++){
    if(respectStop&&(!training||watching))break;

    // Curriculum: öka brädet när frukt-rate (100) > 0.6
    const frRate=avg(fruitHist,100);
    const current=+ui.gridSize.value;
    if(frRate>0.6 && current<+ui.gridSize.max){
      ui.gridSize.value = Math.min(+ui.gridSize.max, current+2);
      ui.gridLabel.textContent=`${ui.gridSize.value}×${ui.gridSize.value}`;
    }

    const n=+ui.gridSize.value;
    if(n!==env.cols){ env=new SnakeEnv(n,n); COLS=n; ROWS=n; CELL=board.width/COLS; setImmediateState(env); stateDim=env.getState().length; }

    let s=env.reset(),done=false,R=0,fr=0,steps=0;
    const resetState=snapshotEnv(env); enqueueRenderFrame(lastDrawnState,resetState,0);
    let aborted=false;
    while(!done){
      if(respectStop&&(!training||watching)){aborted=true;break;}
      const before=snapshotEnv(env);
      const a=agent.act(s);
      const {state:ns,reward:r,done:d}=env.step(a);
      const after=snapshotEnv(env);
      agent.recordTransition(s,a,r,ns,d);
      s=ns; done=d; R+=r; steps++; totalSteps++;
      if(r>1)fr++;

      // lite mer läro-tryck men tidskiva UI-vänligt
      for(let k=0;k<2;k++){
        const loss=await agent.learn();
        if(loss!==null){ lossHist.push(loss); ui.chartLoss.push(avg(lossHist,30)); }
      }
      if(totalSteps%targetSync===0) agent.syncTarget();
      agent.updateEpsilon(totalSteps);
      ui.epsReadout.textContent=agent.epsilon.toFixed(2);

      if(steps%renderEvery===0||d) enqueueRenderFrame(before,after);
      if(steps%24===0) await tf.nextFrame();
    }
    agent.drainPending();
    if(aborted) return;
    episode++;
    rwHist.push(R); if(rwHist.length>1000)rwHist.shift();
    fruitHist.push(fr); if(fruitHist.length>1000)fruitHist.shift();
    bestLen=Math.max(bestLen,env.snake.length);
    ui.kEpisodes.textContent=episode;
    ui.kAvgRw.textContent=avg(rwHist,100).toFixed(2);
    ui.kBest.textContent=bestLen;
    ui.kFruitRate.textContent=avg(fruitHist,100).toFixed(2);
    ui.chartReward.push(R);
    await tf.nextFrame();
    if(respectStop&&(!training||watching))return;
  }
}

async function watchSmoothEpisode(){
  if(watching||!agent)return;
  const wasTraining=training; if(wasTraining)stopTraining();
  watching=true; ui.trainState.textContent='watching'; ui.trainState.style.background='#1a1f46';
  ui.btnWatch && (ui.btnWatch.disabled=true);
  try{
    await waitForRenderIdle();
    const n=+ui.gridSize.value;
    if(n!==env.cols){ env=new SnakeEnv(n,n); COLS=n; ROWS=n; CELL=board.width/COLS; }
    let state=env.reset(); setImmediateState(env);
    const greedyAction=s=>tf.tidy(()=>agent.online.predict(tf.tensor2d([s],[1,stateDim])).argMax(1).dataSync()[0]);
    const maxSteps=COLS*ROWS*6;
    const frameDuration=getWatchDuration();
    let done=false,steps=0;
    while(!done&&steps<maxSteps){
      const before=snapshotEnv(env);
      const action=greedyAction(state);
      const {state:nextState,done:finished}=env.step(action);
      const after=snapshotEnv(env);
      enqueueRenderFrame(before,after,frameDuration);
      state=nextState; done=finished; steps++;
      await waitForRenderCapacity(); await tf.nextFrame();
    }
    await waitForRenderIdle();
    bestLen=Math.max(bestLen,env.snake.length); ui.kBest.textContent=bestLen;
  } finally {
    watching=false; ui.btnWatch && (ui.btnWatch.disabled=false); ui.trainState.style.background='#1a1f46';
    if(wasTraining){ startTraining(); } else { ui.trainState.textContent='idle'; }
  }
}
</script>
</body>
</html>
